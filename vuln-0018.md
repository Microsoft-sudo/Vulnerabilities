# Stored XSS Vulnerabilities in User Authorities Enable Account Takeover

**ID:** vuln-0018
**Severity:** CRITICAL
**Found:** 2026-02-26 16:52:31 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/account
**Method:** GET
**CWE:** CWE-79
**CVSS:** 9.0

## Description

Multiple stored Cross-Site Scripting (XSS) vulnerabilities were discovered in the user authorities field of the commission management application. The application stores and renders user-controlled input in the `all_authorities` field without proper sanitization, allowing malicious JavaScript payloads to be executed in the context of authenticated users' sessions.

The vulnerabilities were identified in the `/api/account` endpoint response, where several XSS payloads were found in the `all_authorities` array:
- `suma\" onmouseover=alert(1) \"`
- `<a href=\"https://www.sumasoft.com/\">CLICK ME</a>`
- `<img src=x onmouseover=alert(1)>`
- `VAPT TESTING`
- `TESTPT`

These payloads demonstrate that the application accepts and stores user-controlled input in security-sensitive fields without proper validation or output encoding.

## Impact

Successful exploitation of these stored XSS vulnerabilities could allow attackers to:

1. **Account Takeover**: Steal session cookies and authentication tokens to hijack user accounts
2. **Privilege Escalation**: Perform actions on behalf of authenticated users, including administrators
3. **Data Theft**: Access sensitive commission data, payout information, and user details
4. **Financial Fraud**: Manipulate commission calculations and payout processes
5. **Malware Distribution**: Deliver malicious payloads to all users accessing the application

The impact is particularly severe given the financial nature of the application and the high privilege level of the Admin role.

## Technical Analysis

The vulnerability exists due to insufficient input validation and output encoding when handling user authorities. The application:

1. **Accepts user-controlled input** in the authorities field without proper validation
2. **Stores malicious payloads** in the database without sanitization
3. **Renders the payloads** in the `/api/account` endpoint response without proper encoding
4. **Allows HTML/JavaScript injection** through various payload formats

The stored XSS payloads are returned in the JSON response from the `/api/account` endpoint, which is likely consumed by the frontend application and rendered in the UI. When these payloads are rendered by the browser, the JavaScript executes in the context of the authenticated user's session.

The vulnerability affects all user roles (Admin, Organization, Client) and can be exploited by any user with the ability to modify their authorities field, potentially through other vulnerabilities or legitimate administrative functions.

## Proof of Concept

To reproduce the stored XSS vulnerability:

1. Authenticate to the application as any user
2. Access the `/api/account` endpoint
3. Observe the malicious XSS payloads in the `all_authorities` field of the response
4. The payloads will execute when rendered in the application UI

Example payloads found in the application:
```json
"all_authorities": [
  "suma\\\" onmouseover=alert(1) \\\"",
  "<a href=\\\"https://www.sumasoft.com/\\\">CLICK ME</a>",
  "<img src=x onmouseover=alert(1)>",
  "VAPT TESTING",
  "TESTPT"
]
```

These payloads demonstrate the ability to inject both HTML and JavaScript into the application.

```
import requests
import json

# Target URL
BASE_URL = "https://commissionstest.callippus.in"
ACCOUNT_ENDPOINT = f"{BASE_URL}/api/account"

# Authenticate to get a valid token
def authenticate():
    auth_url = f"{BASE_URL}/api/authenticate"
    auth_data = {
        "email": "admin@localhost",
        "password": "Tester@123"
    }
    response = requests.post(auth_url, json=auth_data)
    if response.status_code == 200:
        return response.json()["id_token"]
    else:
        raise Exception("Authentication failed")

# Retrieve account information with XSS payloads
def get_account_info(token):
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    response = requests.get(ACCOUNT_ENDPOINT, headers=headers)
    return response.json()

# Demonstrate the vulnerability
def main():
    try:
        # Authenticate
        token = authenticate()
        print(f"Authentication successful. Token: {token[:20]}...")

        # Get account info
        account_info = get_account_info(token)
        print("\nAccount Information:")
        print(f"Username: {account_info.get('login')}")
        print(f"Email: {account_info.get('email')}")
        print(f"Role: {account_info.get('level')}")

        # Extract and display XSS payloads
        print("\nXSS Payloads Found in all_authorities:")
        for i, authority in enumerate(account_info.get('all_authorities', [])):
            if any(payload in authority for payload in ['onmouseover', '<a href', '<img', 'VAPT', 'TESTPT']):
                print(f"{i+1}. {authority}")

        print("\nVulnerability Confirmed: Stored XSS payloads are present in the application and will execute when rendered in the UI.")

    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
```

## Remediation

To remediate these stored XSS vulnerabilities:

1. **Input Validation**:
   - Implement strict input validation for all user-controlled fields, especially security-sensitive fields like authorities
   - Reject any input containing HTML/JavaScript special characters
   - Use allowlists for valid authority values

2. **Output Encoding**:
   - Implement proper output encoding when rendering user-controlled data in the UI
   - Use context-aware encoding (HTML, JavaScript, CSS, URL) based on where the data is rendered
   - Implement Content Security Policy (CSP) headers to mitigate XSS impact

3. **Database Sanitization**:
   - Sanitize existing data in the database to remove malicious payloads
   - Implement database-level constraints to prevent storage of malicious content

4. **Security Headers**:
   - Implement CSP headers with appropriate directives:
     ```
     Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:
     ```
   - Implement X-XSS-Protection header:
     ```
     X-XSS-Protection: 1; mode=block
     ```

5. **Framework Protections**:
   - Use modern frontend frameworks (React, Angular, Vue) that automatically escape content
   - If using legacy frameworks, ensure proper escaping is implemented

6. **Security Testing**:
   - Implement automated security testing to detect XSS vulnerabilities
   - Conduct regular penetration testing to identify and remediate vulnerabilities

7. **User Education**:
   - Train developers on secure coding practices for XSS prevention
   - Implement secure coding guidelines for the development team

